<!DOCTYPE html>
<html lang="en">
<head>
        <title>MacroNode (gyre.nodes.MacroNode)</title>
	<meta charset="utf-8" />
	<meta content="width=device-width, initial-scale=1" name="viewport" />
        <link href="style.css" rel="stylesheet" />
        <script src="script.js" type="text/javascript"></script>

	
	<link href="search-results.html" rel="prefetch" />
</head>
<body>
	<div id="page-header">
		<div id="logotype">
		<span>Documentation</span>
		<nav>
			<a href="http://dlang.org/">Dlang.org</a>
		<a href="https://github.com/baioc/gyred/">GyreD (source)</a></nav>
		</div>

		<form action="search-docs.html" id="search">
			<input name="searchTerm" placeholder="Find a symbol name..." type="search" />
			<input type="submit" value="Go" />
		</form>
	</div>
	<div id="page-body">
		<div id="page-content">
		<h1>MacroNode</h1><div class="breadcrumbs"><a class="breadcrumb" href="gyre.html">gyre</a> <a class="breadcrumb" href="gyre.nodes.html">nodes</a> </div><div><div class="documentation-comment synopsis"><div><p>Gyre's mechanism for structural abstraction, the macro node.</p><p>One can imagine macro nodes as holes: parts of a Gyre program which will only be filled later, like <tt class="inline-code">extern</tt> definitions in a C-like language, which the linker is responsible for resolving.</p></div> <a href="#details" id="more-link">More...</a></div></div><div class="annotated-prototype"><div class="aggregate-prototype"><div class="attributes"><div class="uda">@<span class="name" data-ident="mnemonic">mnemonic</span>(&quot;macro_&quot;) </div></div><span class="builtin-type">struct</span> MacroNode  {<div class="aggregate-member"><a href="gyre.nodes.MacroNode.id.html"><div class="attributes"></div><tt class="highlighted"><span class="hid">ID</span></tt> <span class="name">id</span>;</a></div><div class="aggregate-member"><a href="gyre.nodes.MacroNode.outSlots.html"><div class="attributes"></div><tt class="highlighted"><span class="hid">OutEdge</span>[]</tt> <span class="name">outSlots</span>;</a></div><div class="aggregate-member"><a href="gyre.nodes.MacroNode.inSlots.html"><div class="attributes"></div><tt class="highlighted"><span class="hid">InEdge</span>[]</tt> <span class="name">inSlots</span>;</a></div><div class="aggregate-member"><a href="gyre.nodes.MacroNode.initialize.html"><span class="storage-class">static</span> <tt class="highlighted"><span class="hid">err_t</span></tt> <span class="name">initialize</span>(MacroNode* self, uint id, uint ins, uint outs);</a></div><div class="aggregate-member"><a href="gyre.nodes.MacroNode.dispose.html"><span class="storage-class">static</span> <tt class="highlighted"><span class="type">void</span></tt> <span class="name">dispose</span>(MacroNode* self);</a></div><div class="aggregate-member"><a href="gyre.nodes.MacroNode.opEquals.html"><tt class="highlighted"><span class="type">bool</span></tt> <span class="name">opEquals</span>(const(MacroNode) rhs);</a></div><div class="aggregate-member"><a href="gyre.nodes.MacroNode.toHash.html"><tt class="highlighted"><span class="hid">hash_t</span></tt> <span class="name">toHash</span>();</a></div><div class="aggregate-member"><a href="gyre.nodes.MacroNode.opIndex.html"><tt class="highlighted"><span class="kwrd">inout</span>(<span class="hid">InEdge</span>)*</tt> <span class="name">opIndex</span>(InEdge.ID slot);</a></div><div class="aggregate-member"><a href="gyre.nodes.MacroNode.outEdges.html"><tt class="highlighted"><span class="hid">OutEdgeIterator</span>!<span class="hid">Callable</span></tt> <span class="name">outEdges</span> [@property getter];</a></div><div class="aggregate-member"><a href="gyre.nodes.MacroNode.inEdges.html"><tt class="highlighted"><span class="hid">InEdgeIterator</span>!<span class="hid">Callable</span></tt> <span class="name">inEdges</span> [@property getter];</a></div>}</div></div><h2 id="members">Members</h2><h3 class="member-list-header hide-from-toc" id="function">Functions</h3><dl class="member-list native"><dt><a href="gyre.nodes.MacroNode.opEquals.html">opEquals</a><div class="simplified-prototype" style="max-width: 38ch;"><tt class="highlighted"><span class="type">bool</span></tt> <span class="name">opEquals</span>(const(MacroNode) rhs)</div></dt><dd><div><p>Equivalence check.</p></div></dd><dt><a href="gyre.nodes.MacroNode.opIndex.html">opIndex</a><div class="simplified-prototype" style="max-width: 41ch;"><tt class="highlighted"><span class="kwrd">inout</span>(<span class="hid">InEdge</span>)*</tt> <span class="name">opIndex</span>(InEdge.ID slot)</div></dt><dd><div><p>See <a class="xref" href="gyre.nodes.Node.opIndex.html">Node.opIndex</a>.</p></div></dd><dt><a href="gyre.nodes.MacroNode.toHash.html">toHash</a><div class="simplified-prototype" style="max-width: 16ch;"><tt class="highlighted"><span class="hid">hash_t</span></tt> <span class="name">toHash</span>()</div></dt><dd><div><p>Semantic hash. Depends only on this macro node's id.</p></div></dd></dl><h3 class="member-list-header hide-from-toc" id="property">Properties</h3><dl class="member-list native"><dt><a href="gyre.nodes.MacroNode.inEdges.html">inEdges</a><div class="simplified-prototype" style="max-width: 55ch;"><tt class="highlighted"><span class="hid">InEdgeIterator</span>!<span class="hid">Callable</span></tt> <span class="name">inEdges</span> [@property getter]</div></dt><dd><div><p>Provides an iterator over this node's in-edges.</p></div></dd><dt><a href="gyre.nodes.MacroNode.outEdges.html">outEdges</a><div class="simplified-prototype" style="max-width: 57ch;"><tt class="highlighted"><span class="hid">OutEdgeIterator</span>!<span class="hid">Callable</span></tt> <span class="name">outEdges</span> [@property getter]</div></dt><dd><div><p>Provides an iterator over this node's out-edges.</p></div></dd></dl><h3 class="member-list-header hide-from-toc" id="static function">Static functions</h3><dl class="member-list native"><dt><a href="gyre.nodes.MacroNode.dispose.html">dispose</a><div class="simplified-prototype" style="max-width: 31ch;"><tt class="highlighted"><span class="type">void</span></tt> <span class="name">dispose</span>(MacroNode* self)</div></dt><dd><div><p>Frees all resources allocated by this node and sets it to an uninitialized state.</p></div></dd><dt><a href="gyre.nodes.MacroNode.initialize.html">initialize</a><div class="simplified-prototype" style="max-width: 69ch;"><tt class="highlighted"><span class="hid">err_t</span></tt> <span class="name">initialize</span>(MacroNode* self, uint id, uint ins, uint outs)</div></dt><dd><div><p>Initializes a macro node, must be later <a class="xref" href="gyre.nodes.MacroNode.dispose.html">dispose</a>d.</p></div></dd></dl><h3 class="member-list-header hide-from-toc" id="variable">Variables</h3><dl class="member-list native"><dt><a href="gyre.nodes.MacroNode.id.html">id</a><div class="simplified-prototype" style="max-width: 6ch;"><tt class="highlighted"><span class="hid">ID</span></tt> <span class="name">id</span>;</div></dt><dd><div><p>Links this macro node to its external definition.</p></div></dd><dt><a href="gyre.nodes.MacroNode.inSlots.html">inSlots</a><div class="simplified-prototype" style="max-width: 18ch;"><tt class="highlighted"><span class="hid">InEdge</span>[]</tt> <span class="name">inSlots</span>;</div></dt><dd><div><p>Edges (of any kind) which point into this node.</p></div></dd><dt><a href="gyre.nodes.MacroNode.outSlots.html">outSlots</a><div class="simplified-prototype" style="max-width: 20ch;"><tt class="highlighted"><span class="hid">OutEdge</span>[]</tt> <span class="name">outSlots</span>;</div></dt><dd><div><p>Edges (any kind) which point out from this node.</p></div></dd></dl><h2 id="mixed-in-members">Mixed In Members</h2><h3 id="from-mixin-nodeinheritance-">From <tt class="highlighted"><span class="kwrd">mixin</span> <span class="hid">NodeInheritance</span> </tt></h3><dl class="member-list native"><dt><a href="gyre.nodes.NodeInheritance.opPostMove.html">opPostMove</a><div class="simplified-prototype" style="max-width: 35ch;"><tt class="highlighted"><span class="type">void</span></tt> <span class="name">opPostMove</span>(const(This) old)</div></dt><dd><div><p>Post-move adjusts in-edge slots' owner pointer.</p></div></dd></dl><div><h2 id="details">Detailed Description</h2><div class="documentation-comment detailed-description"><div><p>Macro nodes represent Gyre subgraphs defined elsewhere (external to the graph where they're being used).
A Gyre (sub)program is said to be concrete if it contains no macro nodes, otherwise it is abstract.
This part of Gyre's design is influenced by <a href="https://en.wikipedia.org/wiki/Architecture_Neutral_Distribution_Format">ANDF</a>, which enabled IR &quot;producers&quot; (front ends) to pass along unexpanded macros to IR &quot;installers&quot; (back ends).</p><p>Abstract Gyre graphs can't be directly compiled to machine code, since backends wouldn't be able to lower macro nodes without their definition.
Still, having abstract Gyre graphs has its uses.
One example is when the compiler doesn't (yet) have the information it needs to concretize a graph: it may lack target-specific information which is required for code generation.
Another one is to enable more target-specific optimizations: if every &quot;high-level&quot; operation was lowered to a generic implementation using only primitive nodes, back ends with special support for that operation wouldn't (easily) be able to re-discover it in order to generate specialized code.
<a href="https://storage.googleapis.com/pub-tools-public-publication-data/pdf/85bf23fe88bd5c7ff60365bd0c6882928562cbeb.pdf">&quot;Premature lowering is the root of all evil&quot;</a>, and macro nodes aim to avoid it.</p><p>Without any other rules, macro nodes would probably end up harming portability: abstract Gyre graphs could only be compiled by back ends providing all the right macro definitions.
RULE: Thus, a portable Gyre program must carry definitions for all of its macros (and macros cannot be recursive).
Such definitions must allow any compliant Gyre back end to correctly compile programs by concretizing them through a simple process of macro expansion (i.e. substituting macro nodes for their definition until there are no more macro nodes in the graph).
The intention is that macros must always have the same semantics, but a Gyre compiler with intimate knowledge of a specific macro can do a better job at optimizing programs using it.</p><p>Just like linker-resolved symbols, macro nodes need to be uniquely identified.
It is this identification which allows the compiler to, later in the compilation pipeline, substitute the macro node with (i.e. &quot;link in&quot;) its definition.</p></div></div></div></div>
		<div id="page-nav"><a class="parent" href="gyre.html">gyre</a> <a class="parent" href="gyre.nodes.html">nodes</a> 
		<span class="type-separator">enums</span><ul><li><a class="enum" href="gyre.nodes.EdgeKind.html">EdgeKind</a></li></ul><span class="type-separator">structs</span><ul><li><a class="struct" href="gyre.nodes.AdditionNoOverflowSignedNode.html">AdditionNoOverflowSignedNode</a></li><li><a class="struct" href="gyre.nodes.AdditionNode.html">AdditionNode</a></li><li><a class="struct" href="gyre.nodes.AndNode.html">AndNode</a></li><li><a class="struct" href="gyre.nodes.ConditionalNode.html">ConditionalNode</a></li><li><a class="struct" href="gyre.nodes.ConstantNode.html">ConstantNode</a></li><li><a class="struct" href="gyre.nodes.EqualNode.html">EqualNode</a></li><li><a class="struct" href="gyre.nodes.ForkNode.html">ForkNode</a></li><li><a class="struct" href="gyre.nodes.InEdge.html">InEdge</a></li><li><a class="struct" href="gyre.nodes.InEdgeIterator.html">InEdgeIterator</a></li><li><a class="struct" href="gyre.nodes.InstantiationNode.html">InstantiationNode</a></li><li><a class="struct" href="gyre.nodes.JoinNode.html">JoinNode</a></li><li><a class="struct" href="gyre.nodes.JumpNode.html">JumpNode</a></li><li><a class="struct" href="gyre.nodes.LeftShiftNoOverflowNode.html">LeftShiftNoOverflowNode</a></li><li><a class="struct" href="gyre.nodes.LeftShiftNode.html">LeftShiftNode</a></li><li><a class="struct current" href="gyre.nodes.MacroNode.html">MacroNode</a></li><li><a class="struct" href="gyre.nodes.MultiplexerNode.html">MultiplexerNode</a></li><li><a class="struct" href="gyre.nodes.MultiplicationNoOverflowSignedNode.html">MultiplicationNoOverflowSignedNode</a></li><li><a class="struct" href="gyre.nodes.MultiplicationNode.html">MultiplicationNode</a></li><li><a class="struct" href="gyre.nodes.Node.html">Node</a></li><li><a class="struct" href="gyre.nodes.NotEqualNode.html">NotEqualNode</a></li><li><a class="struct" href="gyre.nodes.OrNode.html">OrNode</a></li><li><a class="struct" href="gyre.nodes.OutEdge.html">OutEdge</a></li><li><a class="struct" href="gyre.nodes.OutEdgeIterator.html">OutEdgeIterator</a></li><li><a class="struct" href="gyre.nodes.SignedDivisionNode.html">SignedDivisionNode</a></li><li><a class="struct" href="gyre.nodes.SignedExtensionNode.html">SignedExtensionNode</a></li><li><a class="struct" href="gyre.nodes.SignedGreaterOrEqualNode.html">SignedGreaterOrEqualNode</a></li><li><a class="struct" href="gyre.nodes.SignedLessThanNode.html">SignedLessThanNode</a></li><li><a class="struct" href="gyre.nodes.SignedRemainderNode.html">SignedRemainderNode</a></li><li><a class="struct" href="gyre.nodes.SignedRightShiftNode.html">SignedRightShiftNode</a></li><li><a class="struct" href="gyre.nodes.SubtractionNoOverflowSignedNode.html">SubtractionNoOverflowSignedNode</a></li><li><a class="struct" href="gyre.nodes.SubtractionNode.html">SubtractionNode</a></li><li><a class="struct" href="gyre.nodes.TruncationNode.html">TruncationNode</a></li><li><a class="struct" href="gyre.nodes.UndefinedNode.html">UndefinedNode</a></li><li><a class="struct" href="gyre.nodes.UnsignedDivisionNode.html">UnsignedDivisionNode</a></li><li><a class="struct" href="gyre.nodes.UnsignedExtensionNode.html">UnsignedExtensionNode</a></li><li><a class="struct" href="gyre.nodes.UnsignedGreaterOrEqualNode.html">UnsignedGreaterOrEqualNode</a></li><li><a class="struct" href="gyre.nodes.UnsignedLessThanNode.html">UnsignedLessThanNode</a></li><li><a class="struct" href="gyre.nodes.UnsignedRemainderNode.html">UnsignedRemainderNode</a></li><li><a class="struct" href="gyre.nodes.UnsignedRightShiftNode.html">UnsignedRightShiftNode</a></li><li><a class="struct" href="gyre.nodes.XorNode.html">XorNode</a></li><li><a class="struct" href="gyre.nodes.mnemonic.html">mnemonic</a></li></ul></div>
	</div>
	<div id="page-footer">Page generated by <a href="https://github.com/adamdruppe/adrdox">adrdox</a></div>
</body>
</html>