<!DOCTYPE html>
<html lang="en">
<head>
        <title>JoinNode (gyre.nodes.JoinNode)</title>
	<meta charset="utf-8" />
	<meta content="width=device-width, initial-scale=1" name="viewport" />
        <link href="style.css" rel="stylesheet" />
        <script src="script.js" type="text/javascript"></script>

	
	<link href="search-results.html" rel="prefetch" />
</head>
<body>
	<div id="page-header">
		<div id="logotype">
		<span>Documentation</span>
		<nav>
			<a href="http://dlang.org/">Dlang.org</a>
		<a href="https://github.com/baioc/gyred/">GyreD (source)</a></nav>
		</div>

		<form action="search-docs.html" id="search">
			<input name="searchTerm" placeholder="Find a symbol name..." type="search" />
			<input type="submit" value="Go" />
		</form>
	</div>
	<div id="page-body">
		<div id="page-content">
		<h1>JoinNode</h1><div class="breadcrumbs"><a class="breadcrumb" href="gyre.html">gyre</a> <a class="breadcrumb" href="gyre.nodes.html">nodes</a> </div><div><div class="documentation-comment synopsis"><div><p>Gyre's main mechanism for procedural abstraction, the join node.</p><p>Join nodes can be used as procedures, basic blocks or synchronization points.</p></div> <a href="#details" id="more-link">More...</a></div></div><div class="annotated-prototype"><div class="aggregate-prototype"><div class="attributes"><div class="uda">@<span class="name" data-ident="mnemonic">mnemonic</span>(&quot;join&quot;) </div></div><span class="builtin-type">struct</span> JoinNode  {<div class="aggregate-member"><a href="gyre.nodes.JoinNode.definition.html"><div class="attributes"></div><tt class="highlighted"><span class="hid">InEdge</span></tt> <span class="name">definition</span>;</a></div><div class="aggregate-member"><a href="gyre.nodes.JoinNode.control.html"><div class="attributes"></div><tt class="highlighted"><span class="hid">OutEdge</span></tt> <span class="name">control</span>;</a></div><div class="aggregate-member"><a href="gyre.nodes.JoinNode.channels.html"><div class="attributes"></div><tt class="highlighted"><span class="hid">InEdge</span>[][]</tt> <span class="name">channels</span>;</a></div><div class="aggregate-member"><a href="gyre.nodes.JoinNode.initialize.html"><span class="storage-class">static</span> <tt class="highlighted"><span class="hid">err_t</span></tt> <span class="name">initialize</span>(JoinNode* self, uint[] sizes);</a></div><div class="aggregate-member"><a href="gyre.nodes.JoinNode.dispose.html"><span class="storage-class">static</span> <tt class="highlighted"><span class="type">void</span></tt> <span class="name">dispose</span>(JoinNode* self);</a></div><div class="aggregate-member"><a href="gyre.nodes.JoinNode.opEquals.html"><tt class="highlighted"><span class="type">bool</span></tt> <span class="name">opEquals</span>(const(JoinNode) rhs);</a></div><div class="aggregate-member"><a href="gyre.nodes.JoinNode.toHash.html"><tt class="highlighted"><span class="hid">hash_t</span></tt> <span class="name">toHash</span>();</a></div><div class="aggregate-member"><a href="gyre.nodes.JoinNode.opIndex.html"><tt class="highlighted"><span class="kwrd">inout</span>(<span class="hid">InEdge</span>)*</tt> <span class="name">opIndex</span>(InEdge.ID slot);</a></div><div class="aggregate-member"><a href="gyre.nodes.JoinNode.outEdges.html"><tt class="highlighted"><span class="hid">OutEdgeIterator</span>!<span class="hid">Callable</span></tt> <span class="name">outEdges</span> [@property getter];</a></div><div class="aggregate-member"><a href="gyre.nodes.JoinNode.inEdges.html"><tt class="highlighted"><span class="hid">InEdgeIterator</span>!<span class="hid">Callable</span></tt> <span class="name">inEdges</span> [@property getter];</a></div>}</div></div><h2 id="members">Members</h2><h3 class="member-list-header hide-from-toc" id="function">Functions</h3><dl class="member-list native"><dt><a href="gyre.nodes.JoinNode.opEquals.html">opEquals</a><div class="simplified-prototype" style="max-width: 37ch;"><tt class="highlighted"><span class="type">bool</span></tt> <span class="name">opEquals</span>(const(JoinNode) rhs)</div></dt><dd><div><p>Equivalence check.</p></div></dd><dt><a href="gyre.nodes.JoinNode.opIndex.html">opIndex</a><div class="simplified-prototype" style="max-width: 41ch;"><tt class="highlighted"><span class="kwrd">inout</span>(<span class="hid">InEdge</span>)*</tt> <span class="name">opIndex</span>(InEdge.ID slot)</div></dt><dd><div><p>See <a class="xref" href="gyre.nodes.Node.opIndex.html">Node.opIndex</a>.</p></div></dd><dt><a href="gyre.nodes.JoinNode.toHash.html">toHash</a><div class="simplified-prototype" style="max-width: 16ch;"><tt class="highlighted"><span class="hid">hash_t</span></tt> <span class="name">toHash</span>()</div></dt><dd><div><p>Semantic hash. Depends only on channel lengths.</p></div></dd></dl><h3 class="member-list-header hide-from-toc" id="property">Properties</h3><dl class="member-list native"><dt><a href="gyre.nodes.JoinNode.inEdges.html">inEdges</a><div class="simplified-prototype" style="max-width: 55ch;"><tt class="highlighted"><span class="hid">InEdgeIterator</span>!<span class="hid">Callable</span></tt> <span class="name">inEdges</span> [@property getter]</div></dt><dd><div><p>Provides an iterator over this node's in-edges.</p></div></dd><dt><a href="gyre.nodes.JoinNode.outEdges.html">outEdges</a><div class="simplified-prototype" style="max-width: 57ch;"><tt class="highlighted"><span class="hid">OutEdgeIterator</span>!<span class="hid">Callable</span></tt> <span class="name">outEdges</span> [@property getter]</div></dt><dd><div><p>Provides an iterator over this node's out-edges.</p></div></dd></dl><h3 class="member-list-header hide-from-toc" id="static function">Static functions</h3><dl class="member-list native"><dt><a href="gyre.nodes.JoinNode.dispose.html">dispose</a><div class="simplified-prototype" style="max-width: 30ch;"><tt class="highlighted"><span class="type">void</span></tt> <span class="name">dispose</span>(JoinNode* self)</div></dt><dd><div><p>Frees all resources allocated by this node and sets it to an uninitialized state.</p></div></dd><dt><a href="gyre.nodes.JoinNode.initialize.html">initialize</a><div class="simplified-prototype" style="max-width: 50ch;"><tt class="highlighted"><span class="hid">err_t</span></tt> <span class="name">initialize</span>(JoinNode* self, uint[] sizes)</div></dt><dd><div><p>Initializes a join node, must be later <a class="xref" href="gyre.nodes.JoinNode.dispose.html">dispose</a>d.</p></div></dd></dl><h3 class="member-list-header hide-from-toc" id="variable">Variables</h3><dl class="member-list native"><dt><a href="gyre.nodes.JoinNode.channels.html">channels</a><div class="simplified-prototype" style="max-width: 22ch;"><tt class="highlighted"><span class="hid">InEdge</span>[][]</tt> <span class="name">channels</span>;</div></dt><dd><div><p>Non-empty collection of channels, each containing zero or more of this node's parameters (either data or memory edges).</p></div></dd><dt><a href="gyre.nodes.JoinNode.control.html">control</a><div class="simplified-prototype" style="max-width: 17ch;"><tt class="highlighted"><span class="hid">OutEdge</span></tt> <span class="name">control</span>;</div></dt><dd><div><p>Control flow edge into the join node's body.</p></div></dd><dt><a href="gyre.nodes.JoinNode.definition.html">definition</a><div class="simplified-prototype" style="max-width: 19ch;"><tt class="highlighted"><span class="hid">InEdge</span></tt> <span class="name">definition</span>;</div></dt><dd><div><p>This join node's definition (a <tt class="inline-code">data</tt> slot), used to instantiate and invoke it.</p></div></dd></dl><h2 id="mixed-in-members">Mixed In Members</h2><h3 id="from-mixin-nodeinheritance-">From <tt class="highlighted"><span class="kwrd">mixin</span> <span class="hid">NodeInheritance</span> </tt></h3><dl class="member-list native"><dt><a href="gyre.nodes.NodeInheritance.opPostMove.html">opPostMove</a><div class="simplified-prototype" style="max-width: 35ch;"><tt class="highlighted"><span class="type">void</span></tt> <span class="name">opPostMove</span>(const(This) old)</div></dt><dd><div><p>Post-move adjusts in-edge slots' owner pointer.</p></div></dd></dl><div><h2 id="details">Detailed Description</h2><div class="documentation-comment detailed-description"><div><p>Join nodes are used to define the (external) interface and (internal) contents of procedures and basic blocks.
They interact with the outside world through zero or more parameters.
As a join node begins to execute, control flows into its body, where all of its parameters are made available.
Therefore, a join node behaves like the entry block of a CFG, but with a collection of SSA phis (one for each parameter); so it can be used as an <a href="https://mlir.llvm.org/docs/Rationale/Rationale/#block-arguments-vs-phi-nodes">extended basic block</a>.
RULE: Gyre graphs can be cyclic, but only if every cycle goes through a join node.
This is similar to having a DFG with SSA phis, in which data-flow can still be considered causal as long as every cycle goes through one or more phi nodes to indicate a &quot;temporal&quot; control-flow dependency.</p><p>Since join nodes define blocks/subprocedures, one may want to know where such a definitions begins and ends.
A join node's scope begins with all of its parameters and control flow edges.
Furthermore, whenever another node is connected to part of a join node's scope, it also becomes part of that scope.
In other words: a join node's scope is implicitly defined by the set of nodes which (a) are transitively reachable by control flow in its body or (b) have a transitive dependency on any one of its parameters.
This idea comes from <a href="https://compilers.cs.uni-saarland.de/papers/lkh15_cgo.pdf">Thorin</a>'s implicit scopes.
RULE: Two scopes cannot intersect unless one is a strict subset of the other.</p><p>The only way in which a Gyre subgraph may refer to a join node without becoming part of its scope is through an indirection: the join node's &quot;definition&quot; edge.
Through its definition, external code may <a class="xref" href="gyre.nodes.InstantiationNode.html">instantiate</a> and <a class="xref" href="gyre.nodes.JumpNode.html">invoke</a> a join node.
Since a join node's body may use any of its parameters, it can only begin executing when they were all provided by the calling code.
Furthermore, parameters are divided into (one or more) groups, called channels.
All parameters within a channel need to be provided at the same time, but each channel can receive its inputs from a different source in the calling code.
Thus, join nodes can also be used to merge concurrent control flows, which should not be surprising to those familiar with the join calculus: join nodes correspond to linear <a href="https://en.wikipedia.org/wiki/Join-pattern">join patterns</a>.</p></div></div><h2 id="see-also">See Also</h2><div class="documentation-comment see-also-section"><div><p><a class="xref" href="gyre.nodes.InstantiationNode.html">InstantiationNode</a>, <a class="xref" href="gyre.nodes.JumpNode.html">JumpNode</a>, <a class="xref" href="gyre.nodes.ForkNode.html">ForkNode</a></p></div></div></div></div>
		<div id="page-nav"><a class="parent" href="gyre.html">gyre</a> <a class="parent" href="gyre.nodes.html">nodes</a> 
		<span class="type-separator">enums</span><ul><li><a class="enum" href="gyre.nodes.EdgeKind.html">EdgeKind</a></li></ul><span class="type-separator">structs</span><ul><li><a class="struct" href="gyre.nodes.AdditionNoOverflowSignedNode.html">AdditionNoOverflowSignedNode</a></li><li><a class="struct" href="gyre.nodes.AdditionNode.html">AdditionNode</a></li><li><a class="struct" href="gyre.nodes.AndNode.html">AndNode</a></li><li><a class="struct" href="gyre.nodes.ConditionalNode.html">ConditionalNode</a></li><li><a class="struct" href="gyre.nodes.ConstantNode.html">ConstantNode</a></li><li><a class="struct" href="gyre.nodes.EqualNode.html">EqualNode</a></li><li><a class="struct" href="gyre.nodes.ForkNode.html">ForkNode</a></li><li><a class="struct" href="gyre.nodes.InEdge.html">InEdge</a></li><li><a class="struct" href="gyre.nodes.InEdgeIterator.html">InEdgeIterator</a></li><li><a class="struct" href="gyre.nodes.InstantiationNode.html">InstantiationNode</a></li><li><a class="struct current" href="gyre.nodes.JoinNode.html">JoinNode</a></li><li><a class="struct" href="gyre.nodes.JumpNode.html">JumpNode</a></li><li><a class="struct" href="gyre.nodes.LeftShiftNoOverflowNode.html">LeftShiftNoOverflowNode</a></li><li><a class="struct" href="gyre.nodes.LeftShiftNode.html">LeftShiftNode</a></li><li><a class="struct" href="gyre.nodes.MacroNode.html">MacroNode</a></li><li><a class="struct" href="gyre.nodes.MultiplexerNode.html">MultiplexerNode</a></li><li><a class="struct" href="gyre.nodes.MultiplicationNoOverflowSignedNode.html">MultiplicationNoOverflowSignedNode</a></li><li><a class="struct" href="gyre.nodes.MultiplicationNode.html">MultiplicationNode</a></li><li><a class="struct" href="gyre.nodes.Node.html">Node</a></li><li><a class="struct" href="gyre.nodes.NotEqualNode.html">NotEqualNode</a></li><li><a class="struct" href="gyre.nodes.OrNode.html">OrNode</a></li><li><a class="struct" href="gyre.nodes.OutEdge.html">OutEdge</a></li><li><a class="struct" href="gyre.nodes.OutEdgeIterator.html">OutEdgeIterator</a></li><li><a class="struct" href="gyre.nodes.SignedDivisionNode.html">SignedDivisionNode</a></li><li><a class="struct" href="gyre.nodes.SignedExtensionNode.html">SignedExtensionNode</a></li><li><a class="struct" href="gyre.nodes.SignedGreaterOrEqualNode.html">SignedGreaterOrEqualNode</a></li><li><a class="struct" href="gyre.nodes.SignedLessThanNode.html">SignedLessThanNode</a></li><li><a class="struct" href="gyre.nodes.SignedRemainderNode.html">SignedRemainderNode</a></li><li><a class="struct" href="gyre.nodes.SignedRightShiftNode.html">SignedRightShiftNode</a></li><li><a class="struct" href="gyre.nodes.SubtractionNoOverflowSignedNode.html">SubtractionNoOverflowSignedNode</a></li><li><a class="struct" href="gyre.nodes.SubtractionNode.html">SubtractionNode</a></li><li><a class="struct" href="gyre.nodes.TruncationNode.html">TruncationNode</a></li><li><a class="struct" href="gyre.nodes.UndefinedNode.html">UndefinedNode</a></li><li><a class="struct" href="gyre.nodes.UnsignedDivisionNode.html">UnsignedDivisionNode</a></li><li><a class="struct" href="gyre.nodes.UnsignedExtensionNode.html">UnsignedExtensionNode</a></li><li><a class="struct" href="gyre.nodes.UnsignedGreaterOrEqualNode.html">UnsignedGreaterOrEqualNode</a></li><li><a class="struct" href="gyre.nodes.UnsignedLessThanNode.html">UnsignedLessThanNode</a></li><li><a class="struct" href="gyre.nodes.UnsignedRemainderNode.html">UnsignedRemainderNode</a></li><li><a class="struct" href="gyre.nodes.UnsignedRightShiftNode.html">UnsignedRightShiftNode</a></li><li><a class="struct" href="gyre.nodes.XorNode.html">XorNode</a></li><li><a class="struct" href="gyre.nodes.mnemonic.html">mnemonic</a></li></ul></div>
	</div>
	<div id="page-footer">Page generated by <a href="https://github.com/adamdruppe/adrdox">adrdox</a></div>
</body>
</html>