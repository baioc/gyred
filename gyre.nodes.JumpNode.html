<!DOCTYPE html>
<html lang="en">
<head>
        <title>JumpNode (gyre.nodes.JumpNode)</title>
	<meta charset="utf-8" />
	<meta content="width=device-width, initial-scale=1" name="viewport" />
        <link href="style.css" rel="stylesheet" />
        <script src="script.js" type="text/javascript"></script>

	
	<link href="search-results.html" rel="prefetch" />
</head>
<body>
	<div id="page-header">
		<div id="logotype">
		<span>Documentation</span>
		<nav>
			<a href="http://dlang.org/">Dlang.org</a>
		<a href="https://github.com/baioc/gyred/">GyreD (source)</a></nav>
		</div>

		<form action="search-docs.html" id="search">
			<input name="searchTerm" placeholder="Find a symbol name..." type="search" />
			<input type="submit" value="Go" />
		</form>
	</div>
	<div id="page-body">
		<div id="page-content">
		<h1>JumpNode</h1><div class="breadcrumbs"><a class="breadcrumb" href="gyre.html">gyre</a> <a class="breadcrumb" href="gyre.nodes.html">nodes</a> </div><div><div class="documentation-comment synopsis"><div><p>Yields control flow to another part of the program through a &quot;jump with arguments&quot;.</p><p>Jump nodes yield control to a target &quot;place&quot; in the program, while also carrying information.
They can be seen as a (a) <tt class="inline-code">goto</tt>, (b) function application, (c) return statement or (d) synchronous message being sent to another process.</p></div> <a href="#details" id="more-link">More...</a></div></div><div class="annotated-prototype"><div class="aggregate-prototype"><div class="attributes"><div class="uda">@<span class="name" data-ident="mnemonic">mnemonic</span>(&quot;jump&quot;) </div></div><span class="builtin-type">struct</span> JumpNode  {<div class="aggregate-member"><a href="gyre.nodes.JumpNode.control.html"><div class="attributes"></div><tt class="highlighted"><span class="hid">InEdge</span></tt> <span class="name">control</span>;</a></div><div class="aggregate-member"><a href="gyre.nodes.JumpNode.continuation.html"><div class="attributes"></div><tt class="highlighted"><span class="hid">OutEdge</span></tt> <span class="name">continuation</span>;</a></div><div class="aggregate-member"><a href="gyre.nodes.JumpNode.arguments.html"><div class="attributes"></div><tt class="highlighted"><span class="hid">OutEdge</span>[]</tt> <span class="name">arguments</span>;</a></div><div class="aggregate-member"><a href="gyre.nodes.JumpNode.initialize.html"><span class="storage-class">static</span> <tt class="highlighted"><span class="hid">err_t</span></tt> <span class="name">initialize</span>(JumpNode* self, uint n);</a></div><div class="aggregate-member"><a href="gyre.nodes.JumpNode.dispose.html"><span class="storage-class">static</span> <tt class="highlighted"><span class="type">void</span></tt> <span class="name">dispose</span>(JumpNode* self);</a></div><div class="aggregate-member"><a href="gyre.nodes.JumpNode.opEquals.html"><tt class="highlighted"><span class="type">bool</span></tt> <span class="name">opEquals</span>(const(JumpNode) rhs);</a></div><div class="aggregate-member"><a href="gyre.nodes.JumpNode.toHash.html"><tt class="highlighted"><span class="hid">hash_t</span></tt> <span class="name">toHash</span>();</a></div><div class="aggregate-member"><a href="gyre.nodes.JumpNode.opIndex.html"><tt class="highlighted"><span class="kwrd">inout</span>(<span class="hid">InEdge</span>)*</tt> <span class="name">opIndex</span>(InEdge.ID slot);</a></div><div class="aggregate-member"><a href="gyre.nodes.JumpNode.outEdges.html"><tt class="highlighted"><span class="hid">OutEdgeIterator</span>!<span class="hid">Callable</span></tt> <span class="name">outEdges</span> [@property getter];</a></div><div class="aggregate-member"><a href="gyre.nodes.JumpNode.inEdges.html"><tt class="highlighted"><span class="hid">InEdgeIterator</span>!<span class="hid">Callable</span></tt> <span class="name">inEdges</span> [@property getter];</a></div>}</div></div><h2 id="members">Members</h2><h3 class="member-list-header hide-from-toc" id="function">Functions</h3><dl class="member-list native"><dt><a href="gyre.nodes.JumpNode.opEquals.html">opEquals</a><div class="simplified-prototype" style="max-width: 37ch;"><tt class="highlighted"><span class="type">bool</span></tt> <span class="name">opEquals</span>(const(JumpNode) rhs)</div></dt><dd><div><p>Equivalence check.</p></div></dd><dt><a href="gyre.nodes.JumpNode.opIndex.html">opIndex</a><div class="simplified-prototype" style="max-width: 41ch;"><tt class="highlighted"><span class="kwrd">inout</span>(<span class="hid">InEdge</span>)*</tt> <span class="name">opIndex</span>(InEdge.ID slot)</div></dt><dd><div><p>See <a class="xref" href="gyre.nodes.Node.opIndex.html">Node.opIndex</a>.</p></div></dd><dt><a href="gyre.nodes.JumpNode.toHash.html">toHash</a><div class="simplified-prototype" style="max-width: 16ch;"><tt class="highlighted"><span class="hid">hash_t</span></tt> <span class="name">toHash</span>()</div></dt><dd><div><p>Semantic hash.</p></div></dd></dl><h3 class="member-list-header hide-from-toc" id="property">Properties</h3><dl class="member-list native"><dt><a href="gyre.nodes.JumpNode.inEdges.html">inEdges</a><div class="simplified-prototype" style="max-width: 55ch;"><tt class="highlighted"><span class="hid">InEdgeIterator</span>!<span class="hid">Callable</span></tt> <span class="name">inEdges</span> [@property getter]</div></dt><dd><div><p>Provides an iterator over this node's in-edges.</p></div></dd><dt><a href="gyre.nodes.JumpNode.outEdges.html">outEdges</a><div class="simplified-prototype" style="max-width: 57ch;"><tt class="highlighted"><span class="hid">OutEdgeIterator</span>!<span class="hid">Callable</span></tt> <span class="name">outEdges</span> [@property getter]</div></dt><dd><div><p>Provides an iterator over this node's out-edges.</p></div></dd></dl><h3 class="member-list-header hide-from-toc" id="static function">Static functions</h3><dl class="member-list native"><dt><a href="gyre.nodes.JumpNode.dispose.html">dispose</a><div class="simplified-prototype" style="max-width: 30ch;"><tt class="highlighted"><span class="type">void</span></tt> <span class="name">dispose</span>(JumpNode* self)</div></dt><dd><div><p>Frees all resources allocated by this node and sets it to an uninitialized state.</p></div></dd><dt><a href="gyre.nodes.JumpNode.initialize.html">initialize</a><div class="simplified-prototype" style="max-width: 44ch;"><tt class="highlighted"><span class="hid">err_t</span></tt> <span class="name">initialize</span>(JumpNode* self, uint n)</div></dt><dd><div><p>Initializes a jump node, must be later <a class="xref" href="gyre.nodes.JumpNode.dispose.html">dispose</a>d.</p></div></dd></dl><h3 class="member-list-header hide-from-toc" id="variable">Variables</h3><dl class="member-list native"><dt><a href="gyre.nodes.JumpNode.arguments.html">arguments</a><div class="simplified-prototype" style="max-width: 22ch;"><tt class="highlighted"><span class="hid">OutEdge</span>[]</tt> <span class="name">arguments</span>;</div></dt><dd><div><p>Arguments to be sent into the continuation and later used inside a join pattern's body.</p></div></dd><dt><a href="gyre.nodes.JumpNode.continuation.html">continuation</a><div class="simplified-prototype" style="max-width: 23ch;"><tt class="highlighted"><span class="hid">OutEdge</span></tt> <span class="name">continuation</span>;</div></dt><dd><div><p>A <tt class="inline-code">data</tt> dependency on some live continuation.</p></div></dd><dt><a href="gyre.nodes.JumpNode.control.html">control</a><div class="simplified-prototype" style="max-width: 16ch;"><tt class="highlighted"><span class="hid">InEdge</span></tt> <span class="name">control</span>;</div></dt><dd><div><p>Incoming control flow which is about to be yielded to the target continuation.</p></div></dd></dl><h2 id="mixed-in-members">Mixed In Members</h2><h3 id="from-mixin-nodeinheritance-">From <tt class="highlighted"><span class="kwrd">mixin</span> <span class="hid">NodeInheritance</span> </tt></h3><dl class="member-list native"><dt><a href="gyre.nodes.NodeInheritance.opPostMove.html">opPostMove</a><div class="simplified-prototype" style="max-width: 35ch;"><tt class="highlighted"><span class="type">void</span></tt> <span class="name">opPostMove</span>(const(This) old)</div></dt><dd><div><p>Post-move adjusts in-edge slots' owner pointer.</p></div></dd></dl><div><h2 id="details">Detailed Description</h2><div class="documentation-comment detailed-description"><div><p>Gyre jumps differ from classic function calls because there is no implicit expectation of a &quot;return&quot;; this is <a href="https://en.wikipedia.org/wiki/Continuation-passing_style">CPS</a>.
If a caller expects return values (or even to take control back at all), it needs to set up a &quot;return continuation&quot; and pass that in as an argument as well, hoping that the subprocedure it is calling will (1) eventually receive messages on all of its other channels, triggering the join pattern; (2) execute the join's body to completion; and (3) have that body jump into the provided continuation as a way to come back (perhaps with a return value) to the calling code.
This is not unlike what we (implicitly) assume of normal functions: their return depends on (1) whether it doesn't go into starvation while waiting for other threads; (2) whether it terminates; and (3) whether it actually has a <tt class="inline-code">return</tt> statement (it could call a C-like <tt class="inline-code">exit</tt> procedure instead, or throw an exception to another part of the call stack).</p><p>Jumps synchronize with each other when they cause a multiple-channel join pattern to trigger.
Imagine a set of concurrent processes, each carrying a continuation corresponding to a different channel of some join pattern; once they've all jumped into their respective continuations, the join triggers and its body executes.
Then, every event in those processes which happens before the jump, also happens before all events in the triggered join pattern's body.
Notice that this does not necessarily apply to single-channel join patterns.</p></div></div><h2 id="see-also">See Also</h2><div class="documentation-comment see-also-section"><div><p><a class="xref" href="gyre.nodes.JoinNode.html">JoinNode</a></p></div></div></div></div>
		<div id="page-nav"><a class="parent" href="gyre.html">gyre</a> <a class="parent" href="gyre.nodes.html">nodes</a> 
		<span class="type-separator">enums</span><ul><li><a class="enum" href="gyre.nodes.EdgeKind.html">EdgeKind</a></li></ul><span class="type-separator">structs</span><ul><li><a class="struct" href="gyre.nodes.AdditionNoOverflowSignedNode.html">AdditionNoOverflowSignedNode</a></li><li><a class="struct" href="gyre.nodes.AdditionNode.html">AdditionNode</a></li><li><a class="struct" href="gyre.nodes.AndNode.html">AndNode</a></li><li><a class="struct" href="gyre.nodes.ConditionalNode.html">ConditionalNode</a></li><li><a class="struct" href="gyre.nodes.ConstantNode.html">ConstantNode</a></li><li><a class="struct" href="gyre.nodes.EqualNode.html">EqualNode</a></li><li><a class="struct" href="gyre.nodes.ForkNode.html">ForkNode</a></li><li><a class="struct" href="gyre.nodes.InEdge.html">InEdge</a></li><li><a class="struct" href="gyre.nodes.InEdgeIterator.html">InEdgeIterator</a></li><li><a class="struct" href="gyre.nodes.InstantiationNode.html">InstantiationNode</a></li><li><a class="struct" href="gyre.nodes.JoinNode.html">JoinNode</a></li><li><a class="struct current" href="gyre.nodes.JumpNode.html">JumpNode</a></li><li><a class="struct" href="gyre.nodes.LeftShiftNoOverflowNode.html">LeftShiftNoOverflowNode</a></li><li><a class="struct" href="gyre.nodes.LeftShiftNode.html">LeftShiftNode</a></li><li><a class="struct" href="gyre.nodes.MacroNode.html">MacroNode</a></li><li><a class="struct" href="gyre.nodes.MultiplexerNode.html">MultiplexerNode</a></li><li><a class="struct" href="gyre.nodes.MultiplicationNoOverflowSignedNode.html">MultiplicationNoOverflowSignedNode</a></li><li><a class="struct" href="gyre.nodes.MultiplicationNode.html">MultiplicationNode</a></li><li><a class="struct" href="gyre.nodes.Node.html">Node</a></li><li><a class="struct" href="gyre.nodes.NotEqualNode.html">NotEqualNode</a></li><li><a class="struct" href="gyre.nodes.OrNode.html">OrNode</a></li><li><a class="struct" href="gyre.nodes.OutEdge.html">OutEdge</a></li><li><a class="struct" href="gyre.nodes.OutEdgeIterator.html">OutEdgeIterator</a></li><li><a class="struct" href="gyre.nodes.SignedDivisionNode.html">SignedDivisionNode</a></li><li><a class="struct" href="gyre.nodes.SignedExtensionNode.html">SignedExtensionNode</a></li><li><a class="struct" href="gyre.nodes.SignedGreaterOrEqualNode.html">SignedGreaterOrEqualNode</a></li><li><a class="struct" href="gyre.nodes.SignedLessThanNode.html">SignedLessThanNode</a></li><li><a class="struct" href="gyre.nodes.SignedRemainderNode.html">SignedRemainderNode</a></li><li><a class="struct" href="gyre.nodes.SignedRightShiftNode.html">SignedRightShiftNode</a></li><li><a class="struct" href="gyre.nodes.SubtractionNoOverflowSignedNode.html">SubtractionNoOverflowSignedNode</a></li><li><a class="struct" href="gyre.nodes.SubtractionNode.html">SubtractionNode</a></li><li><a class="struct" href="gyre.nodes.TruncationNode.html">TruncationNode</a></li><li><a class="struct" href="gyre.nodes.UndefinedNode.html">UndefinedNode</a></li><li><a class="struct" href="gyre.nodes.UnsignedDivisionNode.html">UnsignedDivisionNode</a></li><li><a class="struct" href="gyre.nodes.UnsignedExtensionNode.html">UnsignedExtensionNode</a></li><li><a class="struct" href="gyre.nodes.UnsignedGreaterOrEqualNode.html">UnsignedGreaterOrEqualNode</a></li><li><a class="struct" href="gyre.nodes.UnsignedLessThanNode.html">UnsignedLessThanNode</a></li><li><a class="struct" href="gyre.nodes.UnsignedRemainderNode.html">UnsignedRemainderNode</a></li><li><a class="struct" href="gyre.nodes.UnsignedRightShiftNode.html">UnsignedRightShiftNode</a></li><li><a class="struct" href="gyre.nodes.XorNode.html">XorNode</a></li><li><a class="struct" href="gyre.nodes.mnemonic.html">mnemonic</a></li></ul></div>
	</div>
	<div id="page-footer">Page generated by <a href="https://github.com/adamdruppe/adrdox">adrdox</a></div>
</body>
</html>