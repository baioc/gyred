<!DOCTYPE html>
<html lang="en">
<head>
        <title>gyre.nodes (gyre.nodes)</title>
	<meta charset="utf-8" />
	<meta content="width=device-width, initial-scale=1" name="viewport" />
        <link href="style.css" rel="stylesheet" />
        <script src="script.js" type="text/javascript"></script>

	
	<link href="search-results.html" rel="prefetch" />
</head>
<body>
	<div id="page-header">
		<div id="logotype">
		<span>Documentation</span>
		<nav>
			<a href="http://dlang.org/">Dlang.org</a>
		<a href="https://github.com/baioc/gyred/">GyreD (source)</a></nav>
		</div>

		<form action="search-docs.html" id="search">
			<input name="searchTerm" placeholder="Find a symbol name..." type="search" />
			<input type="submit" value="Go" />
		</form>
	</div>
	<div id="page-body">
		<div id="page-content">
		<h1>gyre.nodes</h1><div class="breadcrumbs"><a class="breadcrumb" href="gyre.html">gyre</a> </div><div><div class="documentation-comment synopsis"><div><p>Structure and interpretation of Gyre nodes.</p><p>This module implements Gyre nodes (and edges).
Each structure's documentation also explains its intended semantics, albeit this may be mixed with implementation details.</p></div> <div id="table-of-contents"><ol class="heading-level-2"><li><a href="#members">Members</a></li><li><a href="#details">Detailed Description</a></li><ol class="heading-level-3"><li><a href="#poison-values-and-ub">Poison values and UB</a></li><li><a href="#prim-ops-rationale">Prim ops rationale</a></li><li><a href="#overflow-semantics">Overflow semantics</a></li></ol></ol></div></div></div><div class="annotated-prototype"></div><h2 id="members">Members</h2><h3 class="member-list-header hide-from-toc" id="enum">Enums</h3><dl class="member-list native"><dt><a href="gyre.nodes.EdgeKind.html">EdgeKind</a><div class="simplified-prototype" style="max-width: 14ch;"><span class="builtin-type">enum</span> <span class="name">EdgeKind</span></div></dt><dd><div><p>Possible edge kinds, or &quot;colors&quot;.</p></div></dd></dl><h3 class="member-list-header hide-from-toc" id="struct">Structs</h3><dl class="member-list native"><dt><a href="gyre.nodes.AdditionNoOverflowSignedNode.html">AdditionNoOverflowSignedNode</a><div class="simplified-prototype" style="max-width: 38ch;"><span class="builtin-type">struct</span> <span class="name">AdditionNoOverflowSignedNode</span></div></dt><dd><div><p>Two's complement <a href="gyre.nodes.html#no-overflow-operations">no-overflow</a> signed addition.</p></div></dd><dt><a href="gyre.nodes.AdditionNode.html">AdditionNode</a><div class="simplified-prototype" style="max-width: 20ch;"><span class="builtin-type">struct</span> <span class="name">AdditionNode</span></div></dt><dd><div><p>Two's complement addition operation (works for both signed and unsigned integers).</p></div></dd><dt><a href="gyre.nodes.AndNode.html">AndNode</a><div class="simplified-prototype" style="max-width: 15ch;"><span class="builtin-type">struct</span> <span class="name">AndNode</span></div></dt><dd><div><p>Bitwise <tt class="inline-code">AND</tt> operation.</p></div></dd><dt><a href="gyre.nodes.ConditionalNode.html">ConditionalNode</a><div class="simplified-prototype" style="max-width: 24ch;"><span class="builtin-type">struct</span> <span class="name">ConditionalNode</span></div></dt><dd><div><p>Directs control flow to exactly one of multiple possible edges.</p></div></dd><dt><a href="gyre.nodes.ConstantNode.html">ConstantNode</a><div class="simplified-prototype" style="max-width: 20ch;"><span class="builtin-type">struct</span> <span class="name">ConstantNode</span></div></dt><dd><div><p>Constructs a constant value of a certain type.</p></div></dd><dt><a href="gyre.nodes.EqualNode.html">EqualNode</a><div class="simplified-prototype" style="max-width: 17ch;"><span class="builtin-type">struct</span> <span class="name">EqualNode</span></div></dt><dd><div><p>Compares two bit patterns for equality.</p></div></dd><dt><a href="gyre.nodes.ForkNode.html">ForkNode</a><div class="simplified-prototype" style="max-width: 16ch;"><span class="builtin-type">struct</span> <span class="name">ForkNode</span></div></dt><dd><div><p>Forks a single control flow into multiple concurrent ones.</p></div></dd><dt><a href="gyre.nodes.InEdge.html">InEdge</a><div class="simplified-prototype" style="max-width: 14ch;"><span class="builtin-type">struct</span> <span class="name">InEdge</span></div></dt><dd><div><p>An in-edge slot.</p></div></dd><dt><a href="gyre.nodes.InEdgeIterator.html">InEdgeIterator</a><div class="simplified-prototype" style="max-width: 34ch;"><span class="builtin-type">struct</span> <span class="name">InEdgeIterator</span><span class="template-params">(Callable)</span></div></dt><dd><div><p>Iterates (with <tt class="inline-code">foreach</tt>) over a node's in-edges.</p></div></dd><dt><a href="gyre.nodes.InstantiationNode.html">InstantiationNode</a><div class="simplified-prototype" style="max-width: 26ch;"><span class="builtin-type">struct</span> <span class="name">InstantiationNode</span></div></dt><dd><div><p>Instantiates a <a class="xref" href="gyre.nodes.JoinNode.html">join node</a>.</p></div></dd><dt><a href="gyre.nodes.JoinNode.html">JoinNode</a><div class="simplified-prototype" style="max-width: 16ch;"><span class="builtin-type">struct</span> <span class="name">JoinNode</span></div></dt><dd><div><p>Gyre's main mechanism for procedural abstraction, the join node.</p></div></dd><dt><a href="gyre.nodes.JumpNode.html">JumpNode</a><div class="simplified-prototype" style="max-width: 16ch;"><span class="builtin-type">struct</span> <span class="name">JumpNode</span></div></dt><dd><div><p>Yields control flow to another part of the program through a &quot;jump with arguments&quot;.</p></div></dd><dt><a href="gyre.nodes.LeftShiftNoOverflowNode.html">LeftShiftNoOverflowNode</a><div class="simplified-prototype" style="max-width: 33ch;"><span class="builtin-type">struct</span> <span class="name">LeftShiftNoOverflowNode</span></div></dt><dd><div><p>Bitwise left-shift with <a href="gyre.nodes.html#no-overflow-operations">no-overflow</a> semantics; shifts in zeros.</p></div></dd><dt><a href="gyre.nodes.LeftShiftNode.html">LeftShiftNode</a><div class="simplified-prototype" style="max-width: 22ch;"><span class="builtin-type">struct</span> <span class="name">LeftShiftNode</span></div></dt><dd><div><p>Bitwise left-shift operation; shifts in zeros.</p></div></dd><dt><a href="gyre.nodes.MacroNode.html">MacroNode</a><div class="simplified-prototype" style="max-width: 17ch;"><span class="builtin-type">struct</span> <span class="name">MacroNode</span></div></dt><dd><div><p>Gyre's mechanism for structural abstraction, the macro node.</p></div></dd><dt><a href="gyre.nodes.MultiplexerNode.html">MultiplexerNode</a><div class="simplified-prototype" style="max-width: 24ch;"><span class="builtin-type">struct</span> <span class="name">MultiplexerNode</span></div></dt><dd><div><p>An operation which chooses one of its inputs to forward as a result.</p></div></dd><dt><a href="gyre.nodes.MultiplicationNoOverflowSignedNode.html">MultiplicationNoOverflowSignedNode</a><div class="simplified-prototype" style="max-width: 45ch;"><span class="builtin-type">struct</span> <span class="name">MultiplicationNoOverflowSignedNode</span></div></dt><dd><div><p>Two's complement <a href="gyre.nodes.html#no-overflow-operations">no-overflow</a> signed multiplication.</p></div></dd><dt><a href="gyre.nodes.MultiplicationNode.html">MultiplicationNode</a><div class="simplified-prototype" style="max-width: 27ch;"><span class="builtin-type">struct</span> <span class="name">MultiplicationNode</span></div></dt><dd><div><p>Two's complement multiplication operation.</p></div></dd><dt><a href="gyre.nodes.Node.html">Node</a><div class="simplified-prototype" style="max-width: 12ch;"><span class="builtin-type">struct</span> <span class="name">Node</span></div></dt><dd><div><p>Common prefix shared by all nodes, safely used ONLY through pointers.</p></div></dd><dt><a href="gyre.nodes.NotEqualNode.html">NotEqualNode</a><div class="simplified-prototype" style="max-width: 20ch;"><span class="builtin-type">struct</span> <span class="name">NotEqualNode</span></div></dt><dd><div><p>Compares two bit patterns for inequality.</p></div></dd><dt><a href="gyre.nodes.OrNode.html">OrNode</a><div class="simplified-prototype" style="max-width: 14ch;"><span class="builtin-type">struct</span> <span class="name">OrNode</span></div></dt><dd><div><p>Bitwise <tt class="inline-code">OR</tt> operation.</p></div></dd><dt><a href="gyre.nodes.OutEdge.html">OutEdge</a><div class="simplified-prototype" style="max-width: 15ch;"><span class="builtin-type">struct</span> <span class="name">OutEdge</span></div></dt><dd><div><p>An outgoing edge.</p></div></dd><dt><a href="gyre.nodes.OutEdgeIterator.html">OutEdgeIterator</a><div class="simplified-prototype" style="max-width: 35ch;"><span class="builtin-type">struct</span> <span class="name">OutEdgeIterator</span><span class="template-params">(Callable)</span></div></dt><dd><div><p>Iterates (with <tt class="inline-code">foreach</tt>) over a node's out-edges.</p></div></dd><dt><a href="gyre.nodes.SignedDivisionNode.html">SignedDivisionNode</a><div class="simplified-prototype" style="max-width: 27ch;"><span class="builtin-type">struct</span> <span class="name">SignedDivisionNode</span></div></dt><dd><div><p>Two's complement division operation for signed operands, rounds towards zero.</p></div></dd><dt><a href="gyre.nodes.SignedExtensionNode.html">SignedExtensionNode</a><div class="simplified-prototype" style="max-width: 28ch;"><span class="builtin-type">struct</span> <span class="name">SignedExtensionNode</span></div></dt><dd><div><p>Yields a wider version of its input, with added bits equal to the input's sign bit.</p></div></dd><dt><a href="gyre.nodes.SignedGreaterOrEqualNode.html">SignedGreaterOrEqualNode</a><div class="simplified-prototype" style="max-width: 34ch;"><span class="builtin-type">struct</span> <span class="name">SignedGreaterOrEqualNode</span></div></dt><dd><div><p>Computes whether a (signed) two's complement integer is greater than or equal to another.</p></div></dd><dt><a href="gyre.nodes.SignedLessThanNode.html">SignedLessThanNode</a><div class="simplified-prototype" style="max-width: 27ch;"><span class="builtin-type">struct</span> <span class="name">SignedLessThanNode</span></div></dt><dd><div><p>Computes whether a (signed) two's complement integer is strictly less than another.</p></div></dd><dt><a href="gyre.nodes.SignedRemainderNode.html">SignedRemainderNode</a><div class="simplified-prototype" style="max-width: 28ch;"><span class="builtin-type">struct</span> <span class="name">SignedRemainderNode</span></div></dt><dd><div><p>Two's complement remainder operation for signed operands, rounds towards zero.</p></div></dd><dt><a href="gyre.nodes.SignedRightShiftNode.html">SignedRightShiftNode</a><div class="simplified-prototype" style="max-width: 29ch;"><span class="builtin-type">struct</span> <span class="name">SignedRightShiftNode</span></div></dt><dd><div><p>Arithmetic right-shift operation; bits shifted in are equal to the input's most significant bit.</p></div></dd><dt><a href="gyre.nodes.SubtractionNoOverflowSignedNode.html">SubtractionNoOverflowSignedNode</a><div class="simplified-prototype" style="max-width: 41ch;"><span class="builtin-type">struct</span> <span class="name">SubtractionNoOverflowSignedNode</span></div></dt><dd><div><p>Two's complement <a href="gyre.nodes.html#no-overflow-operations">no-overflow</a> signed subtraction.</p></div></dd><dt><a href="gyre.nodes.SubtractionNode.html">SubtractionNode</a><div class="simplified-prototype" style="max-width: 24ch;"><span class="builtin-type">struct</span> <span class="name">SubtractionNode</span></div></dt><dd><div><p>Two's complement subtraction operation (works for both signed and unsigned integers).</p></div></dd><dt><a href="gyre.nodes.TruncationNode.html">TruncationNode</a><div class="simplified-prototype" style="max-width: 23ch;"><span class="builtin-type">struct</span> <span class="name">TruncationNode</span></div></dt><dd><div><p>Yields the lowermost bits of its input.</p></div></dd><dt><a href="gyre.nodes.UndefinedNode.html">UndefinedNode</a><div class="simplified-prototype" style="max-width: 22ch;"><span class="builtin-type">struct</span> <span class="name">UndefinedNode</span></div></dt><dd><div><p>Constructs a <a href="https://en.wikipedia.org/wiki/Don%27t-care_term">&quot;don't care&quot;</a> value of a certain type.</p></div></dd><dt><a href="gyre.nodes.UnsignedDivisionNode.html">UnsignedDivisionNode</a><div class="simplified-prototype" style="max-width: 29ch;"><span class="builtin-type">struct</span> <span class="name">UnsignedDivisionNode</span></div></dt><dd><div><p>Two's complement division operation for unsigned operands, rounds towards zero.</p></div></dd><dt><a href="gyre.nodes.UnsignedExtensionNode.html">UnsignedExtensionNode</a><div class="simplified-prototype" style="max-width: 30ch;"><span class="builtin-type">struct</span> <span class="name">UnsignedExtensionNode</span></div></dt><dd><div><p>Yields a wider version of its input, with added bits set to zero.</p></div></dd><dt><a href="gyre.nodes.UnsignedGreaterOrEqualNode.html">UnsignedGreaterOrEqualNode</a><div class="simplified-prototype" style="max-width: 36ch;"><span class="builtin-type">struct</span> <span class="name">UnsignedGreaterOrEqualNode</span></div></dt><dd><div><p>Computes whether a (unsigned) two's complement integer is greater than or equal to another.</p></div></dd><dt><a href="gyre.nodes.UnsignedLessThanNode.html">UnsignedLessThanNode</a><div class="simplified-prototype" style="max-width: 29ch;"><span class="builtin-type">struct</span> <span class="name">UnsignedLessThanNode</span></div></dt><dd><div><p>Computes whether a (unsigned) two's complement integer is strictly less than another.</p></div></dd><dt><a href="gyre.nodes.UnsignedRemainderNode.html">UnsignedRemainderNode</a><div class="simplified-prototype" style="max-width: 30ch;"><span class="builtin-type">struct</span> <span class="name">UnsignedRemainderNode</span></div></dt><dd><div><p>Two's complement remainder operation for unsigned operands, rounds towards zero.</p></div></dd><dt><a href="gyre.nodes.UnsignedRightShiftNode.html">UnsignedRightShiftNode</a><div class="simplified-prototype" style="max-width: 31ch;"><span class="builtin-type">struct</span> <span class="name">UnsignedRightShiftNode</span></div></dt><dd><div><p>Logical right-shift operation; shifts in zeros.</p></div></dd><dt><a href="gyre.nodes.XorNode.html">XorNode</a><div class="simplified-prototype" style="max-width: 15ch;"><span class="builtin-type">struct</span> <span class="name">XorNode</span></div></dt><dd><div><p>Bitwise <tt class="inline-code">XOR</tt> operation.</p></div></dd><dt><a href="gyre.nodes.mnemonic.html">mnemonic</a><div class="simplified-prototype" style="max-width: 16ch;"><span class="builtin-type">struct</span> <span class="name">mnemonic</span></div></dt><dd><div><p>See <a class="xref" href="gyre.mnemonics.html">gyre.mnemonics</a>.</p></div></dd></dl><div><h2 id="details">Detailed Description</h2><div class="documentation-comment detailed-description"><div><h3 class="user-header" id="poison-values-and-ub">Poison values and UB</h3><p>In Gyre, every operation may have some conditions imposed on its inputs in order to produce correct behavior / a sane value.
When the result of a data-only operation isn't well-defined (e.g. <a class="xref" href="gyre.nodes.SignedDivisionNode.html">integer division</a> by zero), it produces a &quot;poison&quot;.
Poison values, as in <a href="https://llvm.org/docs/LangRef.html#poison-values">LLVM</a>, indicate invalid program behavior;  it is as if every instance of a poison value came from the result of <tt class="inline-code">0/0</tt>.
Furthermore, these values are &quot;poisonous&quot; because any operation with a result which depends on a poison operand will also produce poison.
Note that in some cases a result doesn't actually depend on the value of (all of) its operands (e.g. <tt class="inline-code">x * 0</tt> is always <tt class="inline-code">0</tt>).</p><p>This is not unlike C's infamous &quot;Undefined Behavior&quot;, because a Gyre compiler may (while respecting program semantics) assume that poison values are never used, which in turn may help with some optimizations (e.g. <a href="https://en.wikipedia.org/wiki/Loop-invariant_code_motion">loop-invariant code motion</a>).
Another option is to issue warnings or errors when such erroneous behavior is detected.
In this specific implementation, we don't (by default) do aggressive optimizations based on U.B. / poison usage.</p><h3 class="user-header" id="prim-ops-rationale">Prim ops rationale</h3><p>It's hard to justify our choice of primitive operations when we know binary <tt class="inline-code">NAND</tt> would have sufficed to express most of them.
We're essentially copying existing IRs (LLVM, MLIR, Thorin, SPIR-V, WASM, etc), which raise the minimum abstraction level to two's complement integer arithmetic.
Reasoning at that level makes it easier to perform trivial transformations and optimizations (which would require deeper pattern matching if using <tt class="inline-code">NAND</tt>s only).
Then, due to C's status as a <i>de facto</i> <i>lingua franca</i> of programming languages, having our primitive operations match that lowest common denominator will probably benefit compiler performance in most cases, which wouldn't be as true if our primitives were completely different than C's.</p><h3 class="user-header" id="overflow-semantics">Overflow semantics</h3><p>Some of the last primitives to be added were the &quot;no-overflow&quot; variants of some operations.
They could have been expressed with <a class="xref" href="gyre.nodes.MacroNode.html">macro node</a>s, and having them as primitives means that we're introducing more situations in which the same value is being produced at different nodes.
However, the signed versions are very frequent operations in C-derived languages and we wouldn't want the compiler to lose performance whenever they're used.
And they exist for good reason, as they really do help the compiler perform more arithmetic simplifications, especiallly when combining different operations in the same expression (e.g. <tt class="inline-code">(x * 30) / 15</tt> can only be transformed into <tt class="inline-code">x * 2</tt> if overflow is not a possibility).
In short: even if the operation being performed is the same, the no-overflow versions carry more information about their operands.</p><p>To be clear: a no-overflow node performs the same operation as its wrap-on-overflow version, but there's an implicit contract put on its arguments.
This contract states that the operation could have been computed over wider integer types, but the result would still be the same.
As an example, take the expression <tt class="inline-code">(x &lt;&lt; 1) &gt;&gt; 1</tt>.
If we assume that <tt class="inline-code">&lt;&lt;</tt> can overflow (i.e. <tt class="inline-code">x</tt> has a non-zero MSB which is being thrown away), this is equivalent to <tt class="inline-code">x &amp; 0b011...11</tt> (i.e. set the MSB to zero); by assuming that overflow is not possible, the expression can be reduced to just <tt class="inline-code">x</tt> (because if we had used a wider integer, that would have been the result).</p></div></div></div></div>
		<div id="page-nav"><a class="parent" href="gyre.html">gyre</a> 
		<span class="type-separator">modules</span><ul><li><a class="module" href="gyre.graph.html">graph</a></li><li><a class="module" href="gyre.mnemonics.html">mnemonics</a></li><li><a class="module current" href="gyre.nodes.html">nodes</a></li></ul></div>
	</div>
	<div id="page-footer">Page generated by <a href="https://github.com/adamdruppe/adrdox">adrdox</a></div>
</body>
</html>