<!DOCTYPE html>
<html lang="en">
<head>
        <title>ForkNode (gyre.nodes.ForkNode)</title>
	<meta charset="utf-8" />
	<meta content="width=device-width, initial-scale=1" name="viewport" />
        <link href="style.css" rel="stylesheet" />
        <script src="script.js" type="text/javascript"></script>

	
	<link href="search-results.html" rel="prefetch" />
</head>
<body>
	<div id="page-header">
		<div id="logotype">
		<span>Documentation</span>
		<nav>
			<a href="http://dlang.org/">Dlang.org</a>
		<a href="https://github.com/baioc/gyred/">GyreD (source)</a></nav>
		</div>

		<form action="search-docs.html" id="search">
			<input name="searchTerm" placeholder="Find a symbol name..." type="search" />
			<input type="submit" value="Go" />
		</form>
	</div>
	<div id="page-body">
		<div id="page-content">
		<h1>ForkNode</h1><div class="breadcrumbs"><a class="breadcrumb" href="gyre.html">gyre</a> <a class="breadcrumb" href="gyre.nodes.html">nodes</a> </div><div><div class="documentation-comment synopsis"><div><p>Forks a single control flow into multiple concurrent ones.</p><p>Data-only Gyre graphs are always implicitly concurrent: there is no ordering relation between data-only nodes other than the one implied by their def-use chains.
When a node also requires control flow, expressing the fact that it is concurrent with respect to another (i.e. one operation does not necessarily need to happen before the other) is impossible in a classic CFG.
Fork nodes are Gyre's way to work around this limitation by signaling explicit concurrency.</p></div> <a href="#details" id="more-link">More...</a></div></div><div class="annotated-prototype"><div class="aggregate-prototype"><div class="attributes"><div class="uda">@<span class="name" data-ident="mnemonic">mnemonic</span>(&quot;fork&quot;) </div></div><span class="builtin-type">struct</span> ForkNode  {<div class="aggregate-member"><a href="gyre.nodes.ForkNode.control.html"><div class="attributes"></div><tt class="highlighted"><span class="hid">InEdge</span></tt> <span class="name">control</span>;</a></div><div class="aggregate-member"><a href="gyre.nodes.ForkNode.threads.html"><div class="attributes"></div><tt class="highlighted"><span class="hid">OutEdge</span>[]</tt> <span class="name">threads</span>;</a></div><div class="aggregate-member"><a href="gyre.nodes.ForkNode.initialize.html"><span class="storage-class">static</span> <tt class="highlighted"><span class="hid">err_t</span></tt> <span class="name">initialize</span>(ForkNode* self, uint n);</a></div><div class="aggregate-member"><a href="gyre.nodes.ForkNode.dispose.html"><span class="storage-class">static</span> <tt class="highlighted"><span class="type">void</span></tt> <span class="name">dispose</span>(ForkNode* self);</a></div><div class="aggregate-member"><a href="gyre.nodes.ForkNode.opEquals.html"><tt class="highlighted"><span class="type">bool</span></tt> <span class="name">opEquals</span>(const(ForkNode) rhs);</a></div><div class="aggregate-member"><a href="gyre.nodes.ForkNode.toHash.html"><tt class="highlighted"><span class="hid">hash_t</span></tt> <span class="name">toHash</span>();</a></div><div class="aggregate-member"><a href="gyre.nodes.ForkNode.opIndex.html"><tt class="highlighted"><span class="kwrd">inout</span>(<span class="hid">InEdge</span>)*</tt> <span class="name">opIndex</span>(InEdge.ID slot);</a></div><div class="aggregate-member"><a href="gyre.nodes.ForkNode.outEdges.html"><tt class="highlighted"><span class="hid">OutEdgeIterator</span>!<span class="hid">Callable</span></tt> <span class="name">outEdges</span> [@property getter];</a></div><div class="aggregate-member"><a href="gyre.nodes.ForkNode.inEdges.html"><tt class="highlighted"><span class="hid">InEdgeIterator</span>!<span class="hid">Callable</span></tt> <span class="name">inEdges</span> [@property getter];</a></div>}</div></div><h2 id="members">Members</h2><h3 class="member-list-header hide-from-toc" id="function">Functions</h3><dl class="member-list native"><dt><a href="gyre.nodes.ForkNode.opEquals.html">opEquals</a><div class="simplified-prototype" style="max-width: 37ch;"><tt class="highlighted"><span class="type">bool</span></tt> <span class="name">opEquals</span>(const(ForkNode) rhs)</div></dt><dd><div><p>Equivalence check.</p></div></dd><dt><a href="gyre.nodes.ForkNode.opIndex.html">opIndex</a><div class="simplified-prototype" style="max-width: 41ch;"><tt class="highlighted"><span class="kwrd">inout</span>(<span class="hid">InEdge</span>)*</tt> <span class="name">opIndex</span>(InEdge.ID slot)</div></dt><dd><div><p>See <a class="xref" href="gyre.nodes.Node.opIndex.html">Node.opIndex</a>.</p></div></dd><dt><a href="gyre.nodes.ForkNode.toHash.html">toHash</a><div class="simplified-prototype" style="max-width: 16ch;"><tt class="highlighted"><span class="hid">hash_t</span></tt> <span class="name">toHash</span>()</div></dt><dd><div><p>Semantic hash.</p></div></dd></dl><h3 class="member-list-header hide-from-toc" id="property">Properties</h3><dl class="member-list native"><dt><a href="gyre.nodes.ForkNode.inEdges.html">inEdges</a><div class="simplified-prototype" style="max-width: 55ch;"><tt class="highlighted"><span class="hid">InEdgeIterator</span>!<span class="hid">Callable</span></tt> <span class="name">inEdges</span> [@property getter]</div></dt><dd><div><p>Provides an iterator over this node's in-edges.</p></div></dd><dt><a href="gyre.nodes.ForkNode.outEdges.html">outEdges</a><div class="simplified-prototype" style="max-width: 57ch;"><tt class="highlighted"><span class="hid">OutEdgeIterator</span>!<span class="hid">Callable</span></tt> <span class="name">outEdges</span> [@property getter]</div></dt><dd><div><p>Provides an iterator over this node's out-edges.</p></div></dd></dl><h3 class="member-list-header hide-from-toc" id="static function">Static functions</h3><dl class="member-list native"><dt><a href="gyre.nodes.ForkNode.dispose.html">dispose</a><div class="simplified-prototype" style="max-width: 30ch;"><tt class="highlighted"><span class="type">void</span></tt> <span class="name">dispose</span>(ForkNode* self)</div></dt><dd><div><p>Frees all resources allocated by this node and sets it to an uninitialized state.</p></div></dd><dt><a href="gyre.nodes.ForkNode.initialize.html">initialize</a><div class="simplified-prototype" style="max-width: 44ch;"><tt class="highlighted"><span class="hid">err_t</span></tt> <span class="name">initialize</span>(ForkNode* self, uint n)</div></dt><dd><div><p>Initializes a fork node, must be later <a class="xref" href="gyre.nodes.ForkNode.dispose.html">dispose</a>d.</p></div></dd></dl><h3 class="member-list-header hide-from-toc" id="variable">Variables</h3><dl class="member-list native"><dt><a href="gyre.nodes.ForkNode.control.html">control</a><div class="simplified-prototype" style="max-width: 16ch;"><tt class="highlighted"><span class="hid">InEdge</span></tt> <span class="name">control</span>;</div></dt><dd><div><p>Incoming single control flow.</p></div></dd><dt><a href="gyre.nodes.ForkNode.threads.html">threads</a><div class="simplified-prototype" style="max-width: 19ch;"><tt class="highlighted"><span class="hid">OutEdge</span>[]</tt> <span class="name">threads</span>;</div></dt><dd><div><p>At least two concurrent control flows resulting from this fork.</p></div></dd></dl><h2 id="mixed-in-members">Mixed In Members</h2><h3 id="from-mixin-nodeinheritance-">From <tt class="highlighted"><span class="kwrd">mixin</span> <span class="hid">NodeInheritance</span> </tt></h3><dl class="member-list native"><dt><a href="gyre.nodes.NodeInheritance.opPostMove.html">opPostMove</a><div class="simplified-prototype" style="max-width: 35ch;"><tt class="highlighted"><span class="type">void</span></tt> <span class="name">opPostMove</span>(const(This) old)</div></dt><dd><div><p>Post-move adjusts in-edge slots' owner pointer.</p></div></dd></dl><div><h2 id="details">Detailed Description</h2><div class="documentation-comment detailed-description"><div><p>Fork nodes tell the compiler &quot;the following subprograms have no ordering constraints between each other&quot;.
RULE: It is an error for any of the resulting control flows to make direct use of a value produced in another one of its sibling 'threads'.
Still, every event which happens before a fork also happens before the events of its resulting control flows.
Merging multiple concurrent flows back together can be done at a <a class="xref" href="gyre.nodes.JoinNode.html">join</a>.</p><p>TODO: fork semantics are unclear w.r.t. progress. e.g.: when one thread blocks (and it could be waiting for a message from another sibling thread), do all other threads block as well? (in that case, we could have starvation; if other threads don't block, they need to be independently scheduled, which in turn requires help from the OS, etc)</p></div></div><h2 id="see-also">See Also</h2><div class="documentation-comment see-also-section"><div><p><a class="xref" href="gyre.nodes.JoinNode.html">JoinNode</a>, <a class="xref" href="gyre.nodes.JumpNode.html">JumpNode</a></p></div></div></div></div>
		<div id="page-nav"><a class="parent" href="gyre.html">gyre</a> <a class="parent" href="gyre.nodes.html">nodes</a> 
		<span class="type-separator">enums</span><ul><li><a class="enum" href="gyre.nodes.EdgeKind.html">EdgeKind</a></li></ul><span class="type-separator">structs</span><ul><li><a class="struct" href="gyre.nodes.AdditionNoOverflowSignedNode.html">AdditionNoOverflowSignedNode</a></li><li><a class="struct" href="gyre.nodes.AdditionNode.html">AdditionNode</a></li><li><a class="struct" href="gyre.nodes.AndNode.html">AndNode</a></li><li><a class="struct" href="gyre.nodes.ConditionalNode.html">ConditionalNode</a></li><li><a class="struct" href="gyre.nodes.ConstantNode.html">ConstantNode</a></li><li><a class="struct" href="gyre.nodes.EqualNode.html">EqualNode</a></li><li><a class="struct current" href="gyre.nodes.ForkNode.html">ForkNode</a></li><li><a class="struct" href="gyre.nodes.InEdge.html">InEdge</a></li><li><a class="struct" href="gyre.nodes.InEdgeIterator.html">InEdgeIterator</a></li><li><a class="struct" href="gyre.nodes.InstantiationNode.html">InstantiationNode</a></li><li><a class="struct" href="gyre.nodes.JoinNode.html">JoinNode</a></li><li><a class="struct" href="gyre.nodes.JumpNode.html">JumpNode</a></li><li><a class="struct" href="gyre.nodes.LeftShiftNoOverflowNode.html">LeftShiftNoOverflowNode</a></li><li><a class="struct" href="gyre.nodes.LeftShiftNode.html">LeftShiftNode</a></li><li><a class="struct" href="gyre.nodes.MacroNode.html">MacroNode</a></li><li><a class="struct" href="gyre.nodes.MultiplexerNode.html">MultiplexerNode</a></li><li><a class="struct" href="gyre.nodes.MultiplicationNoOverflowSignedNode.html">MultiplicationNoOverflowSignedNode</a></li><li><a class="struct" href="gyre.nodes.MultiplicationNode.html">MultiplicationNode</a></li><li><a class="struct" href="gyre.nodes.Node.html">Node</a></li><li><a class="struct" href="gyre.nodes.NotEqualNode.html">NotEqualNode</a></li><li><a class="struct" href="gyre.nodes.OrNode.html">OrNode</a></li><li><a class="struct" href="gyre.nodes.OutEdge.html">OutEdge</a></li><li><a class="struct" href="gyre.nodes.OutEdgeIterator.html">OutEdgeIterator</a></li><li><a class="struct" href="gyre.nodes.SignedDivisionNode.html">SignedDivisionNode</a></li><li><a class="struct" href="gyre.nodes.SignedExtensionNode.html">SignedExtensionNode</a></li><li><a class="struct" href="gyre.nodes.SignedGreaterOrEqualNode.html">SignedGreaterOrEqualNode</a></li><li><a class="struct" href="gyre.nodes.SignedLessThanNode.html">SignedLessThanNode</a></li><li><a class="struct" href="gyre.nodes.SignedRemainderNode.html">SignedRemainderNode</a></li><li><a class="struct" href="gyre.nodes.SignedRightShiftNode.html">SignedRightShiftNode</a></li><li><a class="struct" href="gyre.nodes.SubtractionNoOverflowSignedNode.html">SubtractionNoOverflowSignedNode</a></li><li><a class="struct" href="gyre.nodes.SubtractionNode.html">SubtractionNode</a></li><li><a class="struct" href="gyre.nodes.TruncationNode.html">TruncationNode</a></li><li><a class="struct" href="gyre.nodes.UndefinedNode.html">UndefinedNode</a></li><li><a class="struct" href="gyre.nodes.UnsignedDivisionNode.html">UnsignedDivisionNode</a></li><li><a class="struct" href="gyre.nodes.UnsignedExtensionNode.html">UnsignedExtensionNode</a></li><li><a class="struct" href="gyre.nodes.UnsignedGreaterOrEqualNode.html">UnsignedGreaterOrEqualNode</a></li><li><a class="struct" href="gyre.nodes.UnsignedLessThanNode.html">UnsignedLessThanNode</a></li><li><a class="struct" href="gyre.nodes.UnsignedRemainderNode.html">UnsignedRemainderNode</a></li><li><a class="struct" href="gyre.nodes.UnsignedRightShiftNode.html">UnsignedRightShiftNode</a></li><li><a class="struct" href="gyre.nodes.XorNode.html">XorNode</a></li><li><a class="struct" href="gyre.nodes.mnemonic.html">mnemonic</a></li></ul></div>
	</div>
	<div id="page-footer">Page generated by <a href="https://github.com/adamdruppe/adrdox">adrdox</a></div>
</body>
</html>