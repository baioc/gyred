<!DOCTYPE html>
<html lang="en">
<head>
        <title>MultiplexerNode (gyre.nodes.MultiplexerNode)</title>
	<meta charset="utf-8" />
	<meta content="width=device-width, initial-scale=1" name="viewport" />
        <link href="style.css" rel="stylesheet" />
        <script src="script.js" type="text/javascript"></script>

	
	<link href="search-results.html" rel="prefetch" />
</head>
<body>
	<div id="page-header">
		<div id="logotype">
		<span>Documentation</span>
		<nav>
			<a href="http://dlang.org/">Dlang.org</a>
		<a href="https://github.com/baioc/gyred/">GyreD (source)</a></nav>
		</div>

		<form action="search-docs.html" id="search">
			<input name="searchTerm" placeholder="Find a symbol name..." type="search" />
			<input type="submit" value="Go" />
		</form>
	</div>
	<div id="page-body">
		<div id="page-content">
		<h1>MultiplexerNode</h1><div class="breadcrumbs"><a class="breadcrumb" href="gyre.html">gyre</a> <a class="breadcrumb" href="gyre.nodes.html">nodes</a> </div><div><div class="documentation-comment synopsis"><div><p>An operation which chooses one of its inputs to forward as a result.</p><p>In a multiplexer node, the choice of which input to forward is controled by an unsigned integer, as if it was indexing an array of inputs.
If the selector's value does not match the index of any input, the result is a <a href="gyre.nodes.html#poison-values-and-ub">poison</a> value.</p></div> <a href="#details" id="more-link">More...</a></div></div><div class="annotated-prototype"><div class="aggregate-prototype"><div class="attributes"><div class="uda">@<span class="name" data-ident="mnemonic">mnemonic</span>(&quot;mux&quot;) </div></div><span class="builtin-type">struct</span> MultiplexerNode  {<div class="aggregate-member"><a href="gyre.nodes.MultiplexerNode.selector.html"><div class="attributes"></div><tt class="highlighted"><span class="hid">OutEdge</span></tt> <span class="name">selector</span>;</a></div><div class="aggregate-member"><a href="gyre.nodes.MultiplexerNode.output.html"><div class="attributes"></div><tt class="highlighted"><span class="hid">InEdge</span></tt> <span class="name">output</span>;</a></div><div class="aggregate-member"><a href="gyre.nodes.MultiplexerNode.inputs.html"><tt class="highlighted"><span class="kwrd">inout</span>(<span class="hid">UnsafeHashMap</span>!(<span class="type">ulong</span>, <span class="hid">OutEdge</span>))</tt> <span class="name">inputs</span> [@property getter];</a></div><div class="aggregate-member"><a href="gyre.nodes.MultiplexerNode.initialize.html"><span class="storage-class">static</span> <tt class="highlighted"><span class="hid">err_t</span></tt> <span class="name">initialize</span>(MultiplexerNode* self, uint n);</a></div><div class="aggregate-member"><a href="gyre.nodes.MultiplexerNode.dispose.html"><span class="storage-class">static</span> <tt class="highlighted"><span class="type">void</span></tt> <span class="name">dispose</span>(MultiplexerNode* self);</a></div><div class="aggregate-member"><a href="gyre.nodes.MultiplexerNode.opEquals.html"><tt class="highlighted"><span class="type">bool</span></tt> <span class="name">opEquals</span>(const(MultiplexerNode) rhs);</a></div><div class="aggregate-member"><a href="gyre.nodes.MultiplexerNode.toHash.html"><tt class="highlighted"><span class="hid">hash_t</span></tt> <span class="name">toHash</span>();</a></div><div class="aggregate-member"><a href="gyre.nodes.MultiplexerNode.opIndex.html"><tt class="highlighted"><span class="kwrd">inout</span>(<span class="hid">InEdge</span>)*</tt> <span class="name">opIndex</span>(InEdge.ID slot);</a></div><div class="aggregate-member"><a href="gyre.nodes.MultiplexerNode.outEdges.html"><tt class="highlighted"><span class="hid">OutEdgeIterator</span>!<span class="hid">Callable</span></tt> <span class="name">outEdges</span> [@property getter];</a></div><div class="aggregate-member"><a href="gyre.nodes.MultiplexerNode.inEdges.html"><tt class="highlighted"><span class="hid">InEdgeIterator</span>!<span class="hid">Callable</span></tt> <span class="name">inEdges</span> [@property getter];</a></div>}</div></div><h2 id="members">Members</h2><h3 class="member-list-header hide-from-toc" id="function">Functions</h3><dl class="member-list native"><dt><a href="gyre.nodes.MultiplexerNode.opEquals.html">opEquals</a><div class="simplified-prototype" style="max-width: 45ch;"><tt class="highlighted"><span class="type">bool</span></tt> <span class="name">opEquals</span>(const(MultiplexerNode) rhs)</div></dt><dd><div><p>Equivalence &lt;=&gt; structural equality.</p></div></dd><dt><a href="gyre.nodes.MultiplexerNode.opIndex.html">opIndex</a><div class="simplified-prototype" style="max-width: 41ch;"><tt class="highlighted"><span class="kwrd">inout</span>(<span class="hid">InEdge</span>)*</tt> <span class="name">opIndex</span>(InEdge.ID slot)</div></dt><dd><div><p>See <a class="xref" href="gyre.nodes.Node.opIndex.html">Node.opIndex</a>.</p></div></dd><dt><a href="gyre.nodes.MultiplexerNode.toHash.html">toHash</a><div class="simplified-prototype" style="max-width: 16ch;"><tt class="highlighted"><span class="hid">hash_t</span></tt> <span class="name">toHash</span>()</div></dt><dd><div><p>Semantic hash.</p></div></dd></dl><h3 class="member-list-header hide-from-toc" id="property">Properties</h3><dl class="member-list native"><dt><a href="gyre.nodes.MultiplexerNode.inEdges.html">inEdges</a><div class="simplified-prototype" style="max-width: 55ch;"><tt class="highlighted"><span class="hid">InEdgeIterator</span>!<span class="hid">Callable</span></tt> <span class="name">inEdges</span> [@property getter]</div></dt><dd><div><p>Provides an iterator over this node's in-edges.</p></div></dd><dt><a href="gyre.nodes.MultiplexerNode.inputs.html">inputs</a><div class="simplified-prototype" style="max-width: 69ch;"><tt class="highlighted"><span class="kwrd">inout</span>(<span class="hid">UnsafeHashMap</span>!(<span class="type">ulong</span>, <span class="hid">OutEdge</span>))</tt> <span class="name">inputs</span> [@property getter]</div></dt><dd><div><p>At least two inputs, one of which will be forwarded as output.</p></div></dd><dt><a href="gyre.nodes.MultiplexerNode.outEdges.html">outEdges</a><div class="simplified-prototype" style="max-width: 57ch;"><tt class="highlighted"><span class="hid">OutEdgeIterator</span>!<span class="hid">Callable</span></tt> <span class="name">outEdges</span> [@property getter]</div></dt><dd><div><p>Provides an iterator over this node's out-edges.</p></div></dd></dl><h3 class="member-list-header hide-from-toc" id="static function">Static functions</h3><dl class="member-list native"><dt><a href="gyre.nodes.MultiplexerNode.dispose.html">dispose</a><div class="simplified-prototype" style="max-width: 38ch;"><tt class="highlighted"><span class="type">void</span></tt> <span class="name">dispose</span>(MultiplexerNode* self)</div></dt><dd><div><p>Frees all resources allocated by this node and sets it to an uninitialized state.</p></div></dd><dt><a href="gyre.nodes.MultiplexerNode.initialize.html">initialize</a><div class="simplified-prototype" style="max-width: 51ch;"><tt class="highlighted"><span class="hid">err_t</span></tt> <span class="name">initialize</span>(MultiplexerNode* self, uint n)</div></dt><dd><div><p>Initializes a multiplexer node, must be later <a class="xref" href="gyre.nodes.MultiplexerNode.dispose.html">dispose</a>d.</p></div></dd></dl><h3 class="member-list-header hide-from-toc" id="variable">Variables</h3><dl class="member-list native"><dt><a href="gyre.nodes.MultiplexerNode.output.html">output</a><div class="simplified-prototype" style="max-width: 15ch;"><tt class="highlighted"><span class="hid">InEdge</span></tt> <span class="name">output</span>;</div></dt><dd><div><p>Resulting value.</p></div></dd><dt><a href="gyre.nodes.MultiplexerNode.selector.html">selector</a><div class="simplified-prototype" style="max-width: 18ch;"><tt class="highlighted"><span class="hid">OutEdge</span></tt> <span class="name">selector</span>;</div></dt><dd><div><p>Data dependency used to choose which of the given inputs will be returned.</p></div></dd></dl><h2 id="mixed-in-members">Mixed In Members</h2><h3 id="from-mixin-nodeinheritance-">From <tt class="highlighted"><span class="kwrd">mixin</span> <span class="hid">NodeInheritance</span> </tt></h3><dl class="member-list native"><dt><a href="gyre.nodes.NodeInheritance.opPostMove.html">opPostMove</a><div class="simplified-prototype" style="max-width: 35ch;"><tt class="highlighted"><span class="type">void</span></tt> <span class="name">opPostMove</span>(const(This) old)</div></dt><dd><div><p>Post-move adjusts in-edge slots' owner pointer.</p></div></dd></dl><div><h2 id="details">Detailed Description</h2><div class="documentation-comment detailed-description"><div><p>The behavior of this node could be emulated by a value-carrying <a class="xref" href="gyre.nodes.ConditionalNode.html">branch</a> into an <a class="xref" href="gyre.nodes.JoinNode.html">extended basic block</a>.
However, this node does not need control flow edges at all.
Thus, its semantics are slightly different: whereas a control flow branch disallows the execution of operations in its unchosen branches (but the compiler can still move them out of the branch if that preserves program semantics), a mux node is allowed to compute all of its options before choosing which one to forward (but doesn't need to, e.g. if the selector is a constant).</p></div></div><h2 id="see-also">See Also</h2><div class="documentation-comment see-also-section"><div><p><a class="xref" href="gyre.nodes.ConditionalNode.html">ConditionalNode</a></p></div></div></div></div>
		<div id="page-nav"><a class="parent" href="gyre.html">gyre</a> <a class="parent" href="gyre.nodes.html">nodes</a> 
		<span class="type-separator">enums</span><ul><li><a class="enum" href="gyre.nodes.EdgeKind.html">EdgeKind</a></li></ul><span class="type-separator">structs</span><ul><li><a class="struct" href="gyre.nodes.AdditionNoOverflowSignedNode.html">AdditionNoOverflowSignedNode</a></li><li><a class="struct" href="gyre.nodes.AdditionNode.html">AdditionNode</a></li><li><a class="struct" href="gyre.nodes.AndNode.html">AndNode</a></li><li><a class="struct" href="gyre.nodes.ConditionalNode.html">ConditionalNode</a></li><li><a class="struct" href="gyre.nodes.ConstantNode.html">ConstantNode</a></li><li><a class="struct" href="gyre.nodes.EqualNode.html">EqualNode</a></li><li><a class="struct" href="gyre.nodes.ForkNode.html">ForkNode</a></li><li><a class="struct" href="gyre.nodes.InEdge.html">InEdge</a></li><li><a class="struct" href="gyre.nodes.InEdgeIterator.html">InEdgeIterator</a></li><li><a class="struct" href="gyre.nodes.InstantiationNode.html">InstantiationNode</a></li><li><a class="struct" href="gyre.nodes.JoinNode.html">JoinNode</a></li><li><a class="struct" href="gyre.nodes.JumpNode.html">JumpNode</a></li><li><a class="struct" href="gyre.nodes.LeftShiftNoOverflowNode.html">LeftShiftNoOverflowNode</a></li><li><a class="struct" href="gyre.nodes.LeftShiftNode.html">LeftShiftNode</a></li><li><a class="struct" href="gyre.nodes.MacroNode.html">MacroNode</a></li><li><a class="struct current" href="gyre.nodes.MultiplexerNode.html">MultiplexerNode</a></li><li><a class="struct" href="gyre.nodes.MultiplicationNoOverflowSignedNode.html">MultiplicationNoOverflowSignedNode</a></li><li><a class="struct" href="gyre.nodes.MultiplicationNode.html">MultiplicationNode</a></li><li><a class="struct" href="gyre.nodes.Node.html">Node</a></li><li><a class="struct" href="gyre.nodes.NotEqualNode.html">NotEqualNode</a></li><li><a class="struct" href="gyre.nodes.OrNode.html">OrNode</a></li><li><a class="struct" href="gyre.nodes.OutEdge.html">OutEdge</a></li><li><a class="struct" href="gyre.nodes.OutEdgeIterator.html">OutEdgeIterator</a></li><li><a class="struct" href="gyre.nodes.SignedDivisionNode.html">SignedDivisionNode</a></li><li><a class="struct" href="gyre.nodes.SignedExtensionNode.html">SignedExtensionNode</a></li><li><a class="struct" href="gyre.nodes.SignedGreaterOrEqualNode.html">SignedGreaterOrEqualNode</a></li><li><a class="struct" href="gyre.nodes.SignedLessThanNode.html">SignedLessThanNode</a></li><li><a class="struct" href="gyre.nodes.SignedRemainderNode.html">SignedRemainderNode</a></li><li><a class="struct" href="gyre.nodes.SignedRightShiftNode.html">SignedRightShiftNode</a></li><li><a class="struct" href="gyre.nodes.SubtractionNoOverflowSignedNode.html">SubtractionNoOverflowSignedNode</a></li><li><a class="struct" href="gyre.nodes.SubtractionNode.html">SubtractionNode</a></li><li><a class="struct" href="gyre.nodes.TruncationNode.html">TruncationNode</a></li><li><a class="struct" href="gyre.nodes.UndefinedNode.html">UndefinedNode</a></li><li><a class="struct" href="gyre.nodes.UnsignedDivisionNode.html">UnsignedDivisionNode</a></li><li><a class="struct" href="gyre.nodes.UnsignedExtensionNode.html">UnsignedExtensionNode</a></li><li><a class="struct" href="gyre.nodes.UnsignedGreaterOrEqualNode.html">UnsignedGreaterOrEqualNode</a></li><li><a class="struct" href="gyre.nodes.UnsignedLessThanNode.html">UnsignedLessThanNode</a></li><li><a class="struct" href="gyre.nodes.UnsignedRemainderNode.html">UnsignedRemainderNode</a></li><li><a class="struct" href="gyre.nodes.UnsignedRightShiftNode.html">UnsignedRightShiftNode</a></li><li><a class="struct" href="gyre.nodes.XorNode.html">XorNode</a></li><li><a class="struct" href="gyre.nodes.mnemonic.html">mnemonic</a></li></ul></div>
	</div>
	<div id="page-footer">Page generated by <a href="https://github.com/adamdruppe/adrdox">adrdox</a></div>
</body>
</html>