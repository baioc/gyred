<!DOCTYPE html>
<html lang="en">
<head>
        <title>Node (gyre.nodes.Node)</title>
	<meta charset="utf-8" />
	<meta content="width=device-width, initial-scale=1" name="viewport" />
        <link href="style.css" rel="stylesheet" />
        <script src="script.js" type="text/javascript"></script>

	
	<link href="search-results.html" rel="prefetch" />
</head>
<body>
	<div id="page-header">
		<div id="logotype">
		<span>Documentation</span>
		<nav>
			<a href="http://dlang.org/">Dlang.org</a>
		<a href="https://github.com/baioc/gyred/">GyreD (source)</a></nav>
		</div>

		<form action="search-docs.html" id="search">
			<input name="searchTerm" placeholder="Find a symbol name..." type="search" />
			<input type="submit" value="Go" />
		</form>
	</div>
	<div id="page-body">
		<div id="page-content">
		<h1>Node</h1><div class="breadcrumbs"><a class="breadcrumb" href="gyre.html">gyre</a> <a class="breadcrumb" href="gyre.nodes.html">nodes</a> </div><div><div class="documentation-comment synopsis"><div><p>Common prefix shared by all nodes, safely used ONLY through pointers.</p><p>References to this substructure can be used as <a href="https://en.wikipedia.org/wiki/Type_punning">type-punned</a> handles to any of our nodes.</p></div> <a href="#details" id="more-link">More...</a></div></div><div class="annotated-prototype"><div class="aggregate-prototype"><div class="attributes"></div><span class="builtin-type">struct</span> Node  {<div class="aggregate-member"><div class="attributes">package </div><tt class="highlighted"><span class="hid">CommonPrefix</span></tt> <span class="name">_node</span>;</div><div class="aggregate-member"><a href="gyre.nodes.Node.updateHash.html"><tt class="highlighted"><span class="type">void</span></tt> <span class="name">updateHash</span>();</a></div><div class="aggregate-member"><a href="gyre.nodes.Node.opEquals.html"><tt class="highlighted"><span class="type">bool</span></tt> <span class="name">opEquals</span>(const(Node) other);</a></div><div class="aggregate-member"><a href="gyre.nodes.Node.toHash.html"><tt class="highlighted"><span class="hid">hash_t</span></tt> <span class="name">toHash</span>();</a></div><div class="aggregate-member"><a href="gyre.nodes.Node.opIndex.html"><tt class="highlighted"><span class="hid">InEdge</span>*</tt> <span class="name">opIndex</span>(InEdge.ID slot);</a></div>}</div></div><h2 id="postblit">Postblit</h2><dl class="member-list"></dl><p>A postblit is present on this object, but not explicitly documented in the source.</p><h2 id="alias-this">Alias This</h2><div><a href="gyre.nodes.Node._node.html">_node</a></div><h2 id="members">Members</h2><h3 class="member-list-header hide-from-toc" id="function">Functions</h3><dl class="member-list native"><dt><a href="gyre.nodes.Node.opEquals.html">opEquals</a><div class="simplified-prototype" style="max-width: 35ch;"><tt class="highlighted"><span class="type">bool</span></tt> <span class="name">opEquals</span>(const(Node) other)</div></dt><dd><div><p>Compares two nodes for equivalence.</p></div></dd><dt><a href="gyre.nodes.Node.opIndex.html">opIndex</a><div class="simplified-prototype" style="max-width: 34ch;"><tt class="highlighted"><span class="hid">InEdge</span>*</tt> <span class="name">opIndex</span>(InEdge.ID slot)</div></dt><dd><div><p>Fetches a specific in-edge slot in this node.</p></div></dd><dt><a href="gyre.nodes.Node.toHash.html">toHash</a><div class="simplified-prototype" style="max-width: 16ch;"><tt class="highlighted"><span class="hid">hash_t</span></tt> <span class="name">toHash</span>()</div></dt><dd><div><p>Returns this node's (assumedly <a class="xref" href="gyre.nodes.Node.updateHash.html">up to date</a>) cached hash value.</p></div></dd><dt><a href="gyre.nodes.Node.updateHash.html">updateHash</a><div class="simplified-prototype" style="max-width: 18ch;"><tt class="highlighted"><span class="type">void</span></tt> <span class="name">updateHash</span>()</div></dt><dd><div><p>Updates a node's cached hash value.</p></div></dd></dl><div><h2 id="details">Detailed Description</h2><div class="documentation-comment detailed-description"><div><p>SSA form is one of Gyre's key aspects.
It can be summarized as an attempt to make program values and variable names correspond one-to-one.
In a graph, we swap 'names' for 'edges' (or pointers, in our case).
We'll try to make all uses of a specific value point to the same edge slot.</p><p>This is essentially <a href="https://en.wikipedia.org/wiki/Value_numbering">GVN</a>.
Doing this perfectly in all cases has a prohibitive canonicalization cost, so we approximate it on a per-node basis: whenever we're about to add a new node to the graph, we'll check if it is redundant, in which case it can be <a href="https://en.wikipedia.org/wiki/Hash_consing">hash-consed</a>, with its uses rewired into the existing graph.
This check requires a way to compare two nodes for equivalence, i.e., whether swapping one for the other preserves program semantics.</p><p>In data-only operations, this usually reduces to structural equality: a node produces the same value (in a corresponding <a class="xref" href="gyre.nodes.InEdge.html">InEdge</a>) as another when they perform the same operation and their inputs are equal (notice the recursion here).
Structural comparisons are relatively expensive operations (especially since the graph could be cyclic), so we want to leverage hashing to do as few comparisons as possible.
Therefore, a node's hash value better reflect its semantic structure: having equal hashes is a necessary (but insufficient) condition for two nodes to be equal.
Now, computing a node's hash value becomes an expensive operation as well, but fortunately it can be cached once a node's structure has stabilized.</p><table class="small-table"><thead><tr><th>Hidden member</th><th>Type</th><th>Description</th></tr></thead><tbody><tr><td><tt class="inline-code">hash</tt></td><td><tt class="inline-code">hash_t</tt></td><td>A node's cached hash value. This is what gets returned when <tt class="inline-code">toHash</tt> is called on a generic <a class="xref" href="gyre.nodes.Node.html">Node</a>, so it should be updated (see <a class="xref" href="gyre.nodes.Node.updateHash.html">updateHash</a>) whenever a node's semantic structure stabilizes.</td></tr><tr><td><tt class="inline-code">asNode</tt></td><td><tt class="inline-code">ref T -&gt; Node*</tt></td><td>Method which upcasts (and this never fails) a concrete node <tt class="inline-code">ref</tt> to a generic <tt class="inline-code">Node*</tt>.</td></tr><tr><td><tt class="inline-code">ofNode</tt></td><td><tt class="inline-code">Node* -&gt; T*</tt></td><td>Static method which tries to downcast a generic <tt class="inline-code">Node*</tt> to a pointer to a concrete type, returning <tt class="inline-code">null</tt> when the cast would have resulted in an invalid reference (so this is technically type-safe).</td></tr></tbody></table></div></div></div></div>
		<div id="page-nav"><a class="parent" href="gyre.html">gyre</a> <a class="parent" href="gyre.nodes.html">nodes</a> 
		<span class="type-separator">enums</span><ul><li><a class="enum" href="gyre.nodes.EdgeKind.html">EdgeKind</a></li></ul><span class="type-separator">structs</span><ul><li><a class="struct" href="gyre.nodes.AdditionNoOverflowSignedNode.html">AdditionNoOverflowSignedNode</a></li><li><a class="struct" href="gyre.nodes.AdditionNode.html">AdditionNode</a></li><li><a class="struct" href="gyre.nodes.AndNode.html">AndNode</a></li><li><a class="struct" href="gyre.nodes.ConditionalNode.html">ConditionalNode</a></li><li><a class="struct" href="gyre.nodes.ConstantNode.html">ConstantNode</a></li><li><a class="struct" href="gyre.nodes.EqualNode.html">EqualNode</a></li><li><a class="struct" href="gyre.nodes.ForkNode.html">ForkNode</a></li><li><a class="struct" href="gyre.nodes.InEdge.html">InEdge</a></li><li><a class="struct" href="gyre.nodes.InEdgeIterator.html">InEdgeIterator</a></li><li><a class="struct" href="gyre.nodes.InstantiationNode.html">InstantiationNode</a></li><li><a class="struct" href="gyre.nodes.JoinNode.html">JoinNode</a></li><li><a class="struct" href="gyre.nodes.JumpNode.html">JumpNode</a></li><li><a class="struct" href="gyre.nodes.LeftShiftNoOverflowNode.html">LeftShiftNoOverflowNode</a></li><li><a class="struct" href="gyre.nodes.LeftShiftNode.html">LeftShiftNode</a></li><li><a class="struct" href="gyre.nodes.MacroNode.html">MacroNode</a></li><li><a class="struct" href="gyre.nodes.MultiplexerNode.html">MultiplexerNode</a></li><li><a class="struct" href="gyre.nodes.MultiplicationNoOverflowSignedNode.html">MultiplicationNoOverflowSignedNode</a></li><li><a class="struct" href="gyre.nodes.MultiplicationNode.html">MultiplicationNode</a></li><li><a class="struct current" href="gyre.nodes.Node.html">Node</a></li><li><a class="struct" href="gyre.nodes.NotEqualNode.html">NotEqualNode</a></li><li><a class="struct" href="gyre.nodes.OrNode.html">OrNode</a></li><li><a class="struct" href="gyre.nodes.OutEdge.html">OutEdge</a></li><li><a class="struct" href="gyre.nodes.OutEdgeIterator.html">OutEdgeIterator</a></li><li><a class="struct" href="gyre.nodes.SignedDivisionNode.html">SignedDivisionNode</a></li><li><a class="struct" href="gyre.nodes.SignedExtensionNode.html">SignedExtensionNode</a></li><li><a class="struct" href="gyre.nodes.SignedGreaterOrEqualNode.html">SignedGreaterOrEqualNode</a></li><li><a class="struct" href="gyre.nodes.SignedLessThanNode.html">SignedLessThanNode</a></li><li><a class="struct" href="gyre.nodes.SignedRemainderNode.html">SignedRemainderNode</a></li><li><a class="struct" href="gyre.nodes.SignedRightShiftNode.html">SignedRightShiftNode</a></li><li><a class="struct" href="gyre.nodes.SubtractionNoOverflowSignedNode.html">SubtractionNoOverflowSignedNode</a></li><li><a class="struct" href="gyre.nodes.SubtractionNode.html">SubtractionNode</a></li><li><a class="struct" href="gyre.nodes.TruncationNode.html">TruncationNode</a></li><li><a class="struct" href="gyre.nodes.UndefinedNode.html">UndefinedNode</a></li><li><a class="struct" href="gyre.nodes.UnsignedDivisionNode.html">UnsignedDivisionNode</a></li><li><a class="struct" href="gyre.nodes.UnsignedExtensionNode.html">UnsignedExtensionNode</a></li><li><a class="struct" href="gyre.nodes.UnsignedGreaterOrEqualNode.html">UnsignedGreaterOrEqualNode</a></li><li><a class="struct" href="gyre.nodes.UnsignedLessThanNode.html">UnsignedLessThanNode</a></li><li><a class="struct" href="gyre.nodes.UnsignedRemainderNode.html">UnsignedRemainderNode</a></li><li><a class="struct" href="gyre.nodes.UnsignedRightShiftNode.html">UnsignedRightShiftNode</a></li><li><a class="struct" href="gyre.nodes.XorNode.html">XorNode</a></li><li><a class="struct" href="gyre.nodes.mnemonic.html">mnemonic</a></li></ul></div>
	</div>
	<div id="page-footer">Page generated by <a href="https://github.com/adamdruppe/adrdox">adrdox</a></div>
</body>
</html>